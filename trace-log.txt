__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
 --- modulename: cp1252, funcname: encode
cp1252.py(19):         return codecs.charmap_encode(input,self.errors,encoding_table)[0]
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(868):             fmt = _defaultFormatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
4724
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1591):         if (found == 0):
mymodules.py(1005):             max_systemPort += 1
mymodules.py(1006):             cursor2.execute("Update smartphones set systemPort=? where id=?",(max_systemPort,row[0]))
mymodules.py(1007):             sqliteConnection.commit()
mymodules.py(1003):         for row in cursor.execute("select * from smartphones"):
mymodules.py(1004):             logger.info(max_systemPort)
 --- modulename: __init__, funcname: info
__init__.py(1377):         if self.isEnabledFor(INFO):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1618):         try:
__init__.py(1619):             return self._cache[level]
__init__.py(1378):             self._log(INFO, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1496):         sinfo = None
__init__.py(1497):         if _srcfile:
__init__.py(1501):             try:
__init__.py(1502):                 fn, lno, func, sinfo = self.findCaller(stack_info)
 --- modulename: __init__, funcname: findCaller
__init__.py(1451):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(154):     currentframe = lambda: sys._getframe(3)
__init__.py(1454):         if f is not None:
__init__.py(1455):             f = f.f_back
__init__.py(1456):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1457):         while hasattr(f, "f_code"):
__init__.py(1458):             co = f.f_code
__init__.py(1459):             filename = os.path.normcase(co.co_filename)
 --- modulename: ntpath, funcname: normcase
ntpath.py(48):     s = os.fspath(s)
ntpath.py(49):     try:
ntpath.py(50):         if isinstance(s, bytes):
ntpath.py(53):             return s.replace('/', '\\').lower()
__init__.py(1460):             if filename == _srcfile:
__init__.py(1463):             sinfo = None
__init__.py(1464):             if stack_info:
__init__.py(1472):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1473):             break
__init__.py(1474):         return rv
__init__.py(1507):         if exc_info:
__init__.py(1512):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1513):                                  exc_info, func, extra, sinfo)
 --- modulename: __init__, funcname: makeRecord
__init__.py(1482):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1483):                              sinfo)
 --- modulename: __init__, funcname: __init__
__init__.py(287):         ct = time.time()
__init__.py(288):         self.name = name
__init__.py(289):         self.msg = msg
__init__.py(308):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(311):         self.args = args
__init__.py(312):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(132):     result = _levelToName.get(level)
__init__.py(133):     if result is not None:
__init__.py(134):         return result
__init__.py(313):         self.levelno = level
__init__.py(314):         self.pathname = pathname
__init__.py(315):         try:
__init__.py(316):             self.filename = os.path.basename(pathname)
 --- modulename: ntpath, funcname: basename
ntpath.py(214):     return split(p)[1]
 --- modulename: ntpath, funcname: split
ntpath.py(183):     p = os.fspath(p)
ntpath.py(184):     seps = _get_bothseps(p)
 --- modulename: ntpath, funcname: _get_bothseps
ntpath.py(35):     if isinstance(path, bytes):
ntpath.py(38):         return '\\/'
ntpath.py(185):     d, p = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(168):         if normp[1:2] == colon:
ntpath.py(169):             return p[:2], p[2:]
ntpath.py(187):     i = len(p)
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(190):     head, tail = p[:i], p[i:]  # now tail has no slashes
ntpath.py(192):     head = head.rstrip(seps) or head
ntpath.py(193):     return d + head, tail
__init__.py(317):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: ntpath, funcname: splitext
ntpath.py(202):     p = os.fspath(p)
ntpath.py(203):     if isinstance(p, bytes):
ntpath.py(206):         return genericpath._splitext(p, '\\', '/', '.')
 --- modulename: genericpath, funcname: _splitext
genericpath.py(124):     sepIndex = p.rfind(sep)
genericpath.py(125):     if altsep:
genericpath.py(126):         altsepIndex = p.rfind(altsep)
genericpath.py(127):         sepIndex = max(sepIndex, altsepIndex)
genericpath.py(129):     dotIndex = p.rfind(extsep)
genericpath.py(130):     if dotIndex > sepIndex:
genericpath.py(132):         filenameIndex = sepIndex + 1
genericpath.py(133):         while filenameIndex < dotIndex:
genericpath.py(134):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(135):                 return p[:dotIndex], p[dotIndex:]
__init__.py(321):         self.exc_info = exc_info
__init__.py(322):         self.exc_text = None      # used to cache the traceback text
__init__.py(323):         self.stack_info = sinfo
__init__.py(324):         self.lineno = lineno
__init__.py(325):         self.funcName = func
__init__.py(326):         self.created = ct
__init__.py(327):         self.msecs = (ct - int(ct)) * 1000
__init__.py(328):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(329):         if logThreads:
__init__.py(330):             self.thread = threading.get_ident()
__init__.py(331):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1072):         assert self._initialized, "Thread.__init__() not called"
threading.py(1073):         return self._name
__init__.py(335):         if not logMultiprocessing: # pragma: no cover
__init__.py(338):             self.processName = 'MainProcess'
__init__.py(339):             mp = sys.modules.get('multiprocessing')
__init__.py(340):             if mp is not None:
__init__.py(345):                 try:
__init__.py(346):                     self.processName = mp.current_process().name
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: name
process.py(182):         return self._name
__init__.py(349):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(350):             self.process = os.getpid()
__init__.py(1484):         if extra is not None:
__init__.py(1489):         return rv
__init__.py(1514):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1523):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(1524):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1580):         c = self
__init__.py(1581):         found = 0
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1125):         if self.stream is None:
__init__.py(1127):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(866):             fmt = self.formatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(610):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(546):         ct = self.converter(record.created)
__init__.py(547):         if datefmt:
__init__.py(550):             t = time.strftime(self.default_time_format, ct)
__init__.py(551):             s = self.default_msec_format % (t, record.msecs)
__init__.py(552):         return s
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
 --- modulename: cp1252, funcname: encode
cp1252.py(19):         return codecs.charmap_encode(input,self.errors,encoding_table)[0]
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(868):             fmt = _defaultFormatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
4725
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1591):         if (found == 0):
mymodules.py(1005):             max_systemPort += 1
mymodules.py(1006):             cursor2.execute("Update smartphones set systemPort=? where id=?",(max_systemPort,row[0]))
mymodules.py(1007):             sqliteConnection.commit()
mymodules.py(1003):         for row in cursor.execute("select * from smartphones"):
mymodules.py(1004):             logger.info(max_systemPort)
 --- modulename: __init__, funcname: info
__init__.py(1377):         if self.isEnabledFor(INFO):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1618):         try:
__init__.py(1619):             return self._cache[level]
__init__.py(1378):             self._log(INFO, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1496):         sinfo = None
__init__.py(1497):         if _srcfile:
__init__.py(1501):             try:
__init__.py(1502):                 fn, lno, func, sinfo = self.findCaller(stack_info)
 --- modulename: __init__, funcname: findCaller
__init__.py(1451):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(154):     currentframe = lambda: sys._getframe(3)
__init__.py(1454):         if f is not None:
__init__.py(1455):             f = f.f_back
__init__.py(1456):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1457):         while hasattr(f, "f_code"):
__init__.py(1458):             co = f.f_code
__init__.py(1459):             filename = os.path.normcase(co.co_filename)
 --- modulename: ntpath, funcname: normcase
ntpath.py(48):     s = os.fspath(s)
ntpath.py(49):     try:
ntpath.py(50):         if isinstance(s, bytes):
ntpath.py(53):             return s.replace('/', '\\').lower()
__init__.py(1460):             if filename == _srcfile:
__init__.py(1463):             sinfo = None
__init__.py(1464):             if stack_info:
__init__.py(1472):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1473):             break
__init__.py(1474):         return rv
__init__.py(1507):         if exc_info:
__init__.py(1512):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1513):                                  exc_info, func, extra, sinfo)
 --- modulename: __init__, funcname: makeRecord
__init__.py(1482):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1483):                              sinfo)
 --- modulename: __init__, funcname: __init__
__init__.py(287):         ct = time.time()
__init__.py(288):         self.name = name
__init__.py(289):         self.msg = msg
__init__.py(308):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(311):         self.args = args
__init__.py(312):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(132):     result = _levelToName.get(level)
__init__.py(133):     if result is not None:
__init__.py(134):         return result
__init__.py(313):         self.levelno = level
__init__.py(314):         self.pathname = pathname
__init__.py(315):         try:
__init__.py(316):             self.filename = os.path.basename(pathname)
 --- modulename: ntpath, funcname: basename
ntpath.py(214):     return split(p)[1]
 --- modulename: ntpath, funcname: split
ntpath.py(183):     p = os.fspath(p)
ntpath.py(184):     seps = _get_bothseps(p)
 --- modulename: ntpath, funcname: _get_bothseps
ntpath.py(35):     if isinstance(path, bytes):
ntpath.py(38):         return '\\/'
ntpath.py(185):     d, p = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(168):         if normp[1:2] == colon:
ntpath.py(169):             return p[:2], p[2:]
ntpath.py(187):     i = len(p)
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(190):     head, tail = p[:i], p[i:]  # now tail has no slashes
ntpath.py(192):     head = head.rstrip(seps) or head
ntpath.py(193):     return d + head, tail
__init__.py(317):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: ntpath, funcname: splitext
ntpath.py(202):     p = os.fspath(p)
ntpath.py(203):     if isinstance(p, bytes):
ntpath.py(206):         return genericpath._splitext(p, '\\', '/', '.')
 --- modulename: genericpath, funcname: _splitext
genericpath.py(124):     sepIndex = p.rfind(sep)
genericpath.py(125):     if altsep:
genericpath.py(126):         altsepIndex = p.rfind(altsep)
genericpath.py(127):         sepIndex = max(sepIndex, altsepIndex)
genericpath.py(129):     dotIndex = p.rfind(extsep)
genericpath.py(130):     if dotIndex > sepIndex:
genericpath.py(132):         filenameIndex = sepIndex + 1
genericpath.py(133):         while filenameIndex < dotIndex:
genericpath.py(134):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(135):                 return p[:dotIndex], p[dotIndex:]
__init__.py(321):         self.exc_info = exc_info
__init__.py(322):         self.exc_text = None      # used to cache the traceback text
__init__.py(323):         self.stack_info = sinfo
__init__.py(324):         self.lineno = lineno
__init__.py(325):         self.funcName = func
__init__.py(326):         self.created = ct
__init__.py(327):         self.msecs = (ct - int(ct)) * 1000
__init__.py(328):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(329):         if logThreads:
__init__.py(330):             self.thread = threading.get_ident()
__init__.py(331):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1072):         assert self._initialized, "Thread.__init__() not called"
threading.py(1073):         return self._name
__init__.py(335):         if not logMultiprocessing: # pragma: no cover
__init__.py(338):             self.processName = 'MainProcess'
__init__.py(339):             mp = sys.modules.get('multiprocessing')
__init__.py(340):             if mp is not None:
__init__.py(345):                 try:
__init__.py(346):                     self.processName = mp.current_process().name
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: name
process.py(182):         return self._name
__init__.py(349):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(350):             self.process = os.getpid()
__init__.py(1484):         if extra is not None:
__init__.py(1489):         return rv
__init__.py(1514):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1523):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(1524):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1580):         c = self
__init__.py(1581):         found = 0
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1125):         if self.stream is None:
__init__.py(1127):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(866):             fmt = self.formatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(610):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(546):         ct = self.converter(record.created)
__init__.py(547):         if datefmt:
__init__.py(550):             t = time.strftime(self.default_time_format, ct)
__init__.py(551):             s = self.default_msec_format % (t, record.msecs)
__init__.py(552):         return s
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
 --- modulename: cp1252, funcname: encode
cp1252.py(19):         return codecs.charmap_encode(input,self.errors,encoding_table)[0]
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(868):             fmt = _defaultFormatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
4726
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1591):         if (found == 0):
mymodules.py(1005):             max_systemPort += 1
mymodules.py(1006):             cursor2.execute("Update smartphones set systemPort=? where id=?",(max_systemPort,row[0]))
mymodules.py(1007):             sqliteConnection.commit()
mymodules.py(1003):         for row in cursor.execute("select * from smartphones"):
mymodules.py(1004):             logger.info(max_systemPort)
 --- modulename: __init__, funcname: info
__init__.py(1377):         if self.isEnabledFor(INFO):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1618):         try:
__init__.py(1619):             return self._cache[level]
__init__.py(1378):             self._log(INFO, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1496):         sinfo = None
__init__.py(1497):         if _srcfile:
__init__.py(1501):             try:
__init__.py(1502):                 fn, lno, func, sinfo = self.findCaller(stack_info)
 --- modulename: __init__, funcname: findCaller
__init__.py(1451):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(154):     currentframe = lambda: sys._getframe(3)
__init__.py(1454):         if f is not None:
__init__.py(1455):             f = f.f_back
__init__.py(1456):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1457):         while hasattr(f, "f_code"):
__init__.py(1458):             co = f.f_code
__init__.py(1459):             filename = os.path.normcase(co.co_filename)
 --- modulename: ntpath, funcname: normcase
ntpath.py(48):     s = os.fspath(s)
ntpath.py(49):     try:
ntpath.py(50):         if isinstance(s, bytes):
ntpath.py(53):             return s.replace('/', '\\').lower()
__init__.py(1460):             if filename == _srcfile:
__init__.py(1463):             sinfo = None
__init__.py(1464):             if stack_info:
__init__.py(1472):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1473):             break
__init__.py(1474):         return rv
__init__.py(1507):         if exc_info:
__init__.py(1512):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1513):                                  exc_info, func, extra, sinfo)
 --- modulename: __init__, funcname: makeRecord
__init__.py(1482):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1483):                              sinfo)
 --- modulename: __init__, funcname: __init__
__init__.py(287):         ct = time.time()
__init__.py(288):         self.name = name
__init__.py(289):         self.msg = msg
__init__.py(308):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(311):         self.args = args
__init__.py(312):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(132):     result = _levelToName.get(level)
__init__.py(133):     if result is not None:
__init__.py(134):         return result
__init__.py(313):         self.levelno = level
__init__.py(314):         self.pathname = pathname
__init__.py(315):         try:
__init__.py(316):             self.filename = os.path.basename(pathname)
 --- modulename: ntpath, funcname: basename
ntpath.py(214):     return split(p)[1]
 --- modulename: ntpath, funcname: split
ntpath.py(183):     p = os.fspath(p)
ntpath.py(184):     seps = _get_bothseps(p)
 --- modulename: ntpath, funcname: _get_bothseps
ntpath.py(35):     if isinstance(path, bytes):
ntpath.py(38):         return '\\/'
ntpath.py(185):     d, p = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(168):         if normp[1:2] == colon:
ntpath.py(169):             return p[:2], p[2:]
ntpath.py(187):     i = len(p)
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(190):     head, tail = p[:i], p[i:]  # now tail has no slashes
ntpath.py(192):     head = head.rstrip(seps) or head
ntpath.py(193):     return d + head, tail
__init__.py(317):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: ntpath, funcname: splitext
ntpath.py(202):     p = os.fspath(p)
ntpath.py(203):     if isinstance(p, bytes):
ntpath.py(206):         return genericpath._splitext(p, '\\', '/', '.')
 --- modulename: genericpath, funcname: _splitext
genericpath.py(124):     sepIndex = p.rfind(sep)
genericpath.py(125):     if altsep:
genericpath.py(126):         altsepIndex = p.rfind(altsep)
genericpath.py(127):         sepIndex = max(sepIndex, altsepIndex)
genericpath.py(129):     dotIndex = p.rfind(extsep)
genericpath.py(130):     if dotIndex > sepIndex:
genericpath.py(132):         filenameIndex = sepIndex + 1
genericpath.py(133):         while filenameIndex < dotIndex:
genericpath.py(134):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(135):                 return p[:dotIndex], p[dotIndex:]
__init__.py(321):         self.exc_info = exc_info
__init__.py(322):         self.exc_text = None      # used to cache the traceback text
__init__.py(323):         self.stack_info = sinfo
__init__.py(324):         self.lineno = lineno
__init__.py(325):         self.funcName = func
__init__.py(326):         self.created = ct
__init__.py(327):         self.msecs = (ct - int(ct)) * 1000
__init__.py(328):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(329):         if logThreads:
__init__.py(330):             self.thread = threading.get_ident()
__init__.py(331):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1072):         assert self._initialized, "Thread.__init__() not called"
threading.py(1073):         return self._name
__init__.py(335):         if not logMultiprocessing: # pragma: no cover
__init__.py(338):             self.processName = 'MainProcess'
__init__.py(339):             mp = sys.modules.get('multiprocessing')
__init__.py(340):             if mp is not None:
__init__.py(345):                 try:
__init__.py(346):                     self.processName = mp.current_process().name
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: name
process.py(182):         return self._name
__init__.py(349):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(350):             self.process = os.getpid()
__init__.py(1484):         if extra is not None:
__init__.py(1489):         return rv
__init__.py(1514):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1523):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(1524):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1580):         c = self
__init__.py(1581):         found = 0
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1125):         if self.stream is None:
__init__.py(1127):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(866):             fmt = self.formatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(610):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(546):         ct = self.converter(record.created)
__init__.py(547):         if datefmt:
__init__.py(550):             t = time.strftime(self.default_time_format, ct)
__init__.py(551):             s = self.default_msec_format % (t, record.msecs)
__init__.py(552):         return s
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
 --- modulename: cp1252, funcname: encode
cp1252.py(19):         return codecs.charmap_encode(input,self.errors,encoding_table)[0]
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(868):             fmt = _defaultFormatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
4727
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1591):         if (found == 0):
mymodules.py(1005):             max_systemPort += 1
mymodules.py(1006):             cursor2.execute("Update smartphones set systemPort=? where id=?",(max_systemPort,row[0]))
mymodules.py(1007):             sqliteConnection.commit()
mymodules.py(1003):         for row in cursor.execute("select * from smartphones"):
mymodules.py(1004):             logger.info(max_systemPort)
 --- modulename: __init__, funcname: info
__init__.py(1377):         if self.isEnabledFor(INFO):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1618):         try:
__init__.py(1619):             return self._cache[level]
__init__.py(1378):             self._log(INFO, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1496):         sinfo = None
__init__.py(1497):         if _srcfile:
__init__.py(1501):             try:
__init__.py(1502):                 fn, lno, func, sinfo = self.findCaller(stack_info)
 --- modulename: __init__, funcname: findCaller
__init__.py(1451):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(154):     currentframe = lambda: sys._getframe(3)
__init__.py(1454):         if f is not None:
__init__.py(1455):             f = f.f_back
__init__.py(1456):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1457):         while hasattr(f, "f_code"):
__init__.py(1458):             co = f.f_code
__init__.py(1459):             filename = os.path.normcase(co.co_filename)
 --- modulename: ntpath, funcname: normcase
ntpath.py(48):     s = os.fspath(s)
ntpath.py(49):     try:
ntpath.py(50):         if isinstance(s, bytes):
ntpath.py(53):             return s.replace('/', '\\').lower()
__init__.py(1460):             if filename == _srcfile:
__init__.py(1463):             sinfo = None
__init__.py(1464):             if stack_info:
__init__.py(1472):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1473):             break
__init__.py(1474):         return rv
__init__.py(1507):         if exc_info:
__init__.py(1512):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1513):                                  exc_info, func, extra, sinfo)
 --- modulename: __init__, funcname: makeRecord
__init__.py(1482):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1483):                              sinfo)
 --- modulename: __init__, funcname: __init__
__init__.py(287):         ct = time.time()
__init__.py(288):         self.name = name
__init__.py(289):         self.msg = msg
__init__.py(308):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(311):         self.args = args
__init__.py(312):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(132):     result = _levelToName.get(level)
__init__.py(133):     if result is not None:
__init__.py(134):         return result
__init__.py(313):         self.levelno = level
__init__.py(314):         self.pathname = pathname
__init__.py(315):         try:
__init__.py(316):             self.filename = os.path.basename(pathname)
 --- modulename: ntpath, funcname: basename
ntpath.py(214):     return split(p)[1]
 --- modulename: ntpath, funcname: split
ntpath.py(183):     p = os.fspath(p)
ntpath.py(184):     seps = _get_bothseps(p)
 --- modulename: ntpath, funcname: _get_bothseps
ntpath.py(35):     if isinstance(path, bytes):
ntpath.py(38):         return '\\/'
ntpath.py(185):     d, p = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(168):         if normp[1:2] == colon:
ntpath.py(169):             return p[:2], p[2:]
ntpath.py(187):     i = len(p)
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(190):     head, tail = p[:i], p[i:]  # now tail has no slashes
ntpath.py(192):     head = head.rstrip(seps) or head
ntpath.py(193):     return d + head, tail
__init__.py(317):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: ntpath, funcname: splitext
ntpath.py(202):     p = os.fspath(p)
ntpath.py(203):     if isinstance(p, bytes):
ntpath.py(206):         return genericpath._splitext(p, '\\', '/', '.')
 --- modulename: genericpath, funcname: _splitext
genericpath.py(124):     sepIndex = p.rfind(sep)
genericpath.py(125):     if altsep:
genericpath.py(126):         altsepIndex = p.rfind(altsep)
genericpath.py(127):         sepIndex = max(sepIndex, altsepIndex)
genericpath.py(129):     dotIndex = p.rfind(extsep)
genericpath.py(130):     if dotIndex > sepIndex:
genericpath.py(132):         filenameIndex = sepIndex + 1
genericpath.py(133):         while filenameIndex < dotIndex:
genericpath.py(134):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(135):                 return p[:dotIndex], p[dotIndex:]
__init__.py(321):         self.exc_info = exc_info
__init__.py(322):         self.exc_text = None      # used to cache the traceback text
__init__.py(323):         self.stack_info = sinfo
__init__.py(324):         self.lineno = lineno
__init__.py(325):         self.funcName = func
__init__.py(326):         self.created = ct
__init__.py(327):         self.msecs = (ct - int(ct)) * 1000
__init__.py(328):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(329):         if logThreads:
__init__.py(330):             self.thread = threading.get_ident()
__init__.py(331):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1072):         assert self._initialized, "Thread.__init__() not called"
threading.py(1073):         return self._name
__init__.py(335):         if not logMultiprocessing: # pragma: no cover
__init__.py(338):             self.processName = 'MainProcess'
__init__.py(339):             mp = sys.modules.get('multiprocessing')
__init__.py(340):             if mp is not None:
__init__.py(345):                 try:
__init__.py(346):                     self.processName = mp.current_process().name
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: name
process.py(182):         return self._name
__init__.py(349):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(350):             self.process = os.getpid()
__init__.py(1484):         if extra is not None:
__init__.py(1489):         return rv
__init__.py(1514):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1523):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(1524):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1580):         c = self
__init__.py(1581):         found = 0
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1125):         if self.stream is None:
__init__.py(1127):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(866):             fmt = self.formatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(610):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(546):         ct = self.converter(record.created)
__init__.py(547):         if datefmt:
__init__.py(550):             t = time.strftime(self.default_time_format, ct)
__init__.py(551):             s = self.default_msec_format % (t, record.msecs)
__init__.py(552):         return s
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
 --- modulename: cp1252, funcname: encode
cp1252.py(19):         return codecs.charmap_encode(input,self.errors,encoding_table)[0]
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(868):             fmt = _defaultFormatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
4728
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1591):         if (found == 0):
mymodules.py(1005):             max_systemPort += 1
mymodules.py(1006):             cursor2.execute("Update smartphones set systemPort=? where id=?",(max_systemPort,row[0]))
mymodules.py(1007):             sqliteConnection.commit()
mymodules.py(1003):         for row in cursor.execute("select * from smartphones"):
mymodules.py(996):     for row in cursor.execute("select id, systemPort from smartphones"):
mymodules.py(1010):     logger.info("We update table smartphones for adding the port for Appium")
 --- modulename: __init__, funcname: info
__init__.py(1377):         if self.isEnabledFor(INFO):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1618):         try:
__init__.py(1619):             return self._cache[level]
__init__.py(1378):             self._log(INFO, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1496):         sinfo = None
__init__.py(1497):         if _srcfile:
__init__.py(1501):             try:
__init__.py(1502):                 fn, lno, func, sinfo = self.findCaller(stack_info)
 --- modulename: __init__, funcname: findCaller
__init__.py(1451):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(154):     currentframe = lambda: sys._getframe(3)
__init__.py(1454):         if f is not None:
__init__.py(1455):             f = f.f_back
__init__.py(1456):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1457):         while hasattr(f, "f_code"):
__init__.py(1458):             co = f.f_code
__init__.py(1459):             filename = os.path.normcase(co.co_filename)
 --- modulename: ntpath, funcname: normcase
ntpath.py(48):     s = os.fspath(s)
ntpath.py(49):     try:
ntpath.py(50):         if isinstance(s, bytes):
ntpath.py(53):             return s.replace('/', '\\').lower()
__init__.py(1460):             if filename == _srcfile:
__init__.py(1463):             sinfo = None
__init__.py(1464):             if stack_info:
__init__.py(1472):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1473):             break
__init__.py(1474):         return rv
__init__.py(1507):         if exc_info:
__init__.py(1512):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1513):                                  exc_info, func, extra, sinfo)
 --- modulename: __init__, funcname: makeRecord
__init__.py(1482):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1483):                              sinfo)
 --- modulename: __init__, funcname: __init__
__init__.py(287):         ct = time.time()
__init__.py(288):         self.name = name
__init__.py(289):         self.msg = msg
__init__.py(308):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(311):         self.args = args
__init__.py(312):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(132):     result = _levelToName.get(level)
__init__.py(133):     if result is not None:
__init__.py(134):         return result
__init__.py(313):         self.levelno = level
__init__.py(314):         self.pathname = pathname
__init__.py(315):         try:
__init__.py(316):             self.filename = os.path.basename(pathname)
 --- modulename: ntpath, funcname: basename
ntpath.py(214):     return split(p)[1]
 --- modulename: ntpath, funcname: split
ntpath.py(183):     p = os.fspath(p)
ntpath.py(184):     seps = _get_bothseps(p)
 --- modulename: ntpath, funcname: _get_bothseps
ntpath.py(35):     if isinstance(path, bytes):
ntpath.py(38):         return '\\/'
ntpath.py(185):     d, p = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(168):         if normp[1:2] == colon:
ntpath.py(169):             return p[:2], p[2:]
ntpath.py(187):     i = len(p)
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(189):         i -= 1
ntpath.py(188):     while i and p[i-1] not in seps:
ntpath.py(190):     head, tail = p[:i], p[i:]  # now tail has no slashes
ntpath.py(192):     head = head.rstrip(seps) or head
ntpath.py(193):     return d + head, tail
__init__.py(317):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: ntpath, funcname: splitext
ntpath.py(202):     p = os.fspath(p)
ntpath.py(203):     if isinstance(p, bytes):
ntpath.py(206):         return genericpath._splitext(p, '\\', '/', '.')
 --- modulename: genericpath, funcname: _splitext
genericpath.py(124):     sepIndex = p.rfind(sep)
genericpath.py(125):     if altsep:
genericpath.py(126):         altsepIndex = p.rfind(altsep)
genericpath.py(127):         sepIndex = max(sepIndex, altsepIndex)
genericpath.py(129):     dotIndex = p.rfind(extsep)
genericpath.py(130):     if dotIndex > sepIndex:
genericpath.py(132):         filenameIndex = sepIndex + 1
genericpath.py(133):         while filenameIndex < dotIndex:
genericpath.py(134):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(135):                 return p[:dotIndex], p[dotIndex:]
__init__.py(321):         self.exc_info = exc_info
__init__.py(322):         self.exc_text = None      # used to cache the traceback text
__init__.py(323):         self.stack_info = sinfo
__init__.py(324):         self.lineno = lineno
__init__.py(325):         self.funcName = func
__init__.py(326):         self.created = ct
__init__.py(327):         self.msecs = (ct - int(ct)) * 1000
__init__.py(328):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(329):         if logThreads:
__init__.py(330):             self.thread = threading.get_ident()
__init__.py(331):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1072):         assert self._initialized, "Thread.__init__() not called"
threading.py(1073):         return self._name
__init__.py(335):         if not logMultiprocessing: # pragma: no cover
__init__.py(338):             self.processName = 'MainProcess'
__init__.py(339):             mp = sys.modules.get('multiprocessing')
__init__.py(340):             if mp is not None:
__init__.py(345):                 try:
__init__.py(346):                     self.processName = mp.current_process().name
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: name
process.py(182):         return self._name
__init__.py(349):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(350):             self.process = os.getpid()
__init__.py(1484):         if extra is not None:
__init__.py(1489):         return rv
__init__.py(1514):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1523):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(1524):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1580):         c = self
__init__.py(1581):         found = 0
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1125):         if self.stream is None:
__init__.py(1127):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(866):             fmt = self.formatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(610):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(546):         ct = self.converter(record.created)
__init__.py(547):         if datefmt:
__init__.py(550):             t = time.strftime(self.default_time_format, ct)
__init__.py(551):             s = self.default_msec_format % (t, record.msecs)
__init__.py(552):         return s
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
 --- modulename: cp1252, funcname: encode
cp1252.py(19):         return codecs.charmap_encode(input,self.errors,encoding_table)[0]
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1584):                 found = found + 1
__init__.py(1585):                 if record.levelno >= hdlr.level:
__init__.py(1586):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(890):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(748):         rv = True
__init__.py(749):         for f in self.filters:
__init__.py(757):         return rv
__init__.py(891):         if rv:
__init__.py(892):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(893):             try:
__init__.py(894):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1024):         try:
__init__.py(1025):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(865):         if self.formatter:
__init__.py(868):             fmt = _defaultFormatter
__init__.py(869):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(608):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(367):         msg = str(self.msg)
__init__.py(368):         if self.args:
__init__.py(370):         return msg
__init__.py(609):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(577):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(419):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(611):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(580):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(422):         return self._fmt % record.__dict__
__init__.py(612):         if record.exc_info:
__init__.py(617):         if record.exc_text:
__init__.py(621):         if record.stack_info:
__init__.py(625):         return s
__init__.py(1026):             stream = self.stream
__init__.py(1028):             stream.write(msg + self.terminator)
We update table smartphones for adding the port for Appium
__init__.py(1029):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1006):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(842):         if self.lock:
__init__.py(843):             self.lock.acquire()
__init__.py(1007):         try:
__init__.py(1008):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1009):                 self.stream.flush()
__init__.py(1011):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(896):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(849):         if self.lock:
__init__.py(850):             self.lock.release()
__init__.py(897):         return rv
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1583):             for hdlr in c.handlers:
__init__.py(1587):             if not c.propagate:
__init__.py(1590):                 c = c.parent
__init__.py(1582):         while c:
__init__.py(1591):         if (found == 0):
mymodules.py(1012):     cursor.close()
mymodules.py(1013):     cursor2.close()
mymodules.py(1014):     sqliteConnection.close()
PhoneBot.py(556):         with concurrent.futures.ProcessPoolExecutor() as executor:
 --- modulename: __init__, funcname: __getattr__
__init__.py(42):     if name == 'ProcessPoolExecutor':
__init__.py(43):         from .process import ProcessPoolExecutor as pe
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(422):  --- modulename: _bootstrap, funcname: _find_and_load
<frozen importlib._bootstrap>(980):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(144): <frozen importlib._bootstrap>(145):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(148):  --- modulename: _bootstrap, funcname: _get_module_lock
<frozen importlib._bootstrap>(163): <frozen importlib._bootstrap>(164): <frozen importlib._bootstrap>(165): <frozen importlib._bootstrap>(166): <frozen importlib._bootstrap>(167): <frozen importlib._bootstrap>(168): <frozen importlib._bootstrap>(170): <frozen importlib._bootstrap>(171): <frozen importlib._bootstrap>(174):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(59): <frozen importlib._bootstrap>(60): <frozen importlib._bootstrap>(61): <frozen importlib._bootstrap>(62): <frozen importlib._bootstrap>(63): <frozen importlib._bootstrap>(64): <frozen importlib._bootstrap>(176): <frozen importlib._bootstrap>(187): <frozen importlib._bootstrap>(189): <frozen importlib._bootstrap>(191): <frozen importlib._bootstrap>(149):  --- modulename: _bootstrap, funcname: acquire
<frozen importlib._bootstrap>(84): <frozen importlib._bootstrap>(85): <frozen importlib._bootstrap>(86): <frozen importlib._bootstrap>(87): <frozen importlib._bootstrap>(88): <frozen importlib._bootstrap>(89): <frozen importlib._bootstrap>(90): <frozen importlib._bootstrap>(91): <frozen importlib._bootstrap>(92): <frozen importlib._bootstrap>(101): <frozen importlib._bootstrap>(981): <frozen importlib._bootstrap>(982): <frozen importlib._bootstrap>(983):  --- modulename: _bootstrap, funcname: _find_and_load_unlocked
<frozen importlib._bootstrap>(949): <frozen importlib._bootstrap>(950): <frozen importlib._bootstrap>(951): <frozen importlib._bootstrap>(952): <frozen importlib._bootstrap>(955): <frozen importlib._bootstrap>(957): <frozen importlib._bootstrap>(958): <frozen importlib._bootstrap>(959): <frozen importlib._bootstrap>(963):  --- modulename: _bootstrap, funcname: _find_spec
<frozen importlib._bootstrap>(884): <frozen importlib._bootstrap>(885): <frozen importlib._bootstrap>(890): <frozen importlib._bootstrap>(896): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap, funcname: find_spec
<frozen importlib._bootstrap>(721): <frozen importlib._bootstrap>(722):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap, funcname: find_spec
<frozen importlib._bootstrap>(794): <frozen importlib._bootstrap>(797):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap_external, funcname: find_spec
<frozen importlib._bootstrap_external>(1278): <frozen importlib._bootstrap_external>(1280):  --- modulename: _bootstrap_external, funcname: _get_spec
<frozen importlib._bootstrap_external>(1245): <frozen importlib._bootstrap_external>(1246): <frozen importlib._bootstrap_external>(1247): <frozen importlib._bootstrap_external>(1249):  --- modulename: _bootstrap_external, funcname: _path_importer_cache
<frozen importlib._bootstrap_external>(1211): <frozen importlib._bootstrap_external>(1218): <frozen importlib._bootstrap_external>(1219): <frozen importlib._bootstrap_external>(1223): <frozen importlib._bootstrap_external>(1250): <frozen importlib._bootstrap_external>(1251): <frozen importlib._bootstrap_external>(1252):  --- modulename: _bootstrap_external, funcname: find_spec
<frozen importlib._bootstrap_external>(1361): <frozen importlib._bootstrap_external>(1362): <frozen importlib._bootstrap_external>(1363): <frozen importlib._bootstrap_external>(1364):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(1367): <frozen importlib._bootstrap_external>(1371):  --- modulename: _bootstrap_external, funcname: _relax_case
<frozen importlib._bootstrap_external>(38): <frozen importlib._bootstrap_external>(1375): <frozen importlib._bootstrap_external>(1376): <frozen importlib._bootstrap_external>(1378): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1394):  --- modulename: _bootstrap_external, funcname: _path_isfile
<frozen importlib._bootstrap_external>(95):  --- modulename: _bootstrap_external, funcname: _path_is_mode_type
<frozen importlib._bootstrap_external>(86): <frozen importlib._bootstrap_external>(87):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(90): <frozen importlib._bootstrap_external>(1395): <frozen importlib._bootstrap_external>(1396):  --- modulename: _bootstrap_external, funcname: _get_spec
<frozen importlib._bootstrap_external>(1352):  --- modulename: _bootstrap_external, funcname: __init__
<frozen importlib._bootstrap_external>(887): <frozen importlib._bootstrap_external>(888): <frozen importlib._bootstrap_external>(1353): <frozen importlib._bootstrap_external>(1354):  --- modulename: _bootstrap_external, funcname: spec_from_file_location
<frozen importlib._bootstrap_external>(586): <frozen importlib._bootstrap_external>(598): <frozen importlib._bootstrap_external>(606):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(371): <frozen importlib._bootstrap>(372): <frozen importlib._bootstrap>(373): <frozen importlib._bootstrap>(374): <frozen importlib._bootstrap>(375): <frozen importlib._bootstrap>(378): <frozen importlib._bootstrap>(379): <frozen importlib._bootstrap_external>(607): <frozen importlib._bootstrap_external>(610): <frozen importlib._bootstrap_external>(620): <frozen importlib._bootstrap_external>(631): <frozen importlib._bootstrap_external>(632): <frozen importlib._bootstrap_external>(637): <frozen importlib._bootstrap_external>(1255): <frozen importlib._bootstrap_external>(1257): <frozen importlib._bootstrap_external>(1258): <frozen importlib._bootstrap_external>(1281): <frozen importlib._bootstrap_external>(1283): <frozen importlib._bootstrap_external>(1294):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(909): <frozen importlib._bootstrap>(924): <frozen importlib._bootstrap>(964): <frozen importlib._bootstrap>(967):  --- modulename: _bootstrap, funcname: _load_unlocked
<frozen importlib._bootstrap>(665): <frozen importlib._bootstrap>(667): <frozen importlib._bootstrap>(670):  --- modulename: _bootstrap, funcname: module_from_spec
<frozen importlib._bootstrap>(579): <frozen importlib._bootstrap>(580): <frozen importlib._bootstrap>(583):  --- modulename: _bootstrap_external, funcname: create_module
<frozen importlib._bootstrap_external>(720): <frozen importlib._bootstrap>(587): <frozen importlib._bootstrap>(588):  --- modulename: _bootstrap, funcname: _new_module
<frozen importlib._bootstrap>(36): <frozen importlib._bootstrap>(589):  --- modulename: _bootstrap, funcname: _init_module_attrs
<frozen importlib._bootstrap>(508): <frozen importlib._bootstrap>(514): <frozen importlib._bootstrap>(515): <frozen importlib._bootstrap>(516): <frozen importlib._bootstrap>(537): <frozen importlib._bootstrap>(538): <frozen importlib._bootstrap>(542): <frozen importlib._bootstrap>(543): <frozen importlib._bootstrap>(544):  --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420): <frozen importlib._bootstrap>(548): <frozen importlib._bootstrap>(549): <frozen importlib._bootstrap>(553): <frozen importlib._bootstrap>(554): <frozen importlib._bootstrap>(560):  --- modulename: _bootstrap, funcname: has_location
<frozen importlib._bootstrap>(426): <frozen importlib._bootstrap>(561): <frozen importlib._bootstrap>(562): <frozen importlib._bootstrap>(563): <frozen importlib._bootstrap>(567): <frozen importlib._bootstrap>(568):  --- modulename: _bootstrap, funcname: cached
<frozen importlib._bootstrap>(405): <frozen importlib._bootstrap>(406): <frozen importlib._bootstrap>(407): <frozen importlib._bootstrap>(409):  --- modulename: _bootstrap_external, funcname: _get_cached
<frozen importlib._bootstrap_external>(370): <frozen importlib._bootstrap_external>(371): <frozen importlib._bootstrap_external>(372):  --- modulename: _bootstrap_external, funcname: cache_from_source
<frozen importlib._bootstrap_external>(289): <frozen importlib._bootstrap_external>(296): <frozen importlib._bootstrap_external>(297):  --- modulename: _bootstrap_external, funcname: _path_split
<frozen importlib._bootstrap_external>(64): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(69): <frozen importlib._bootstrap_external>(70): <frozen importlib._bootstrap_external>(298): <frozen importlib._bootstrap_external>(299): <frozen importlib._bootstrap_external>(300): <frozen importlib._bootstrap_external>(302): <frozen importlib._bootstrap_external>(303): <frozen importlib._bootstrap_external>(304): <frozen importlib._bootstrap_external>(305): <frozen importlib._bootstrap_external>(308): <frozen importlib._bootstrap_external>(309): <frozen importlib._bootstrap_external>(313):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap>(410): <frozen importlib._bootstrap>(569): <frozen importlib._bootstrap>(570):  --- modulename: _bootstrap, funcname: cached
<frozen importlib._bootstrap>(405): <frozen importlib._bootstrap>(410): <frozen importlib._bootstrap>(573): <frozen importlib._bootstrap>(590): <frozen importlib._bootstrap>(671):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(308): <frozen importlib._bootstrap>(309):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(315): <frozen importlib._bootstrap>(316): <frozen importlib._bootstrap>(672): <frozen importlib._bootstrap>(677):  --- modulename: _bootstrap_external, funcname: exec_module
<frozen importlib._bootstrap_external>(724):  --- modulename: _bootstrap_external, funcname: get_code
<frozen importlib._bootstrap_external>(800):  --- modulename: _bootstrap_external, funcname: _check_name_wrapper
<frozen importlib._bootstrap_external>(402): <frozen importlib._bootstrap_external>(404): <frozen importlib._bootstrap_external>(407):  --- modulename: _bootstrap_external, funcname: get_filename
<frozen importlib._bootstrap_external>(912): <frozen importlib._bootstrap_external>(801): <frozen importlib._bootstrap_external>(802): <frozen importlib._bootstrap_external>(803): <frozen importlib._bootstrap_external>(804): <frozen importlib._bootstrap_external>(805): <frozen importlib._bootstrap_external>(806): <frozen importlib._bootstrap_external>(807):  --- modulename: _bootstrap_external, funcname: cache_from_source
<frozen importlib._bootstrap_external>(289): <frozen importlib._bootstrap_external>(296): <frozen importlib._bootstrap_external>(297):  --- modulename: _bootstrap_external, funcname: _path_split
<frozen importlib._bootstrap_external>(64): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(69): <frozen importlib._bootstrap_external>(70): <frozen importlib._bootstrap_external>(298): <frozen importlib._bootstrap_external>(299): <frozen importlib._bootstrap_external>(300): <frozen importlib._bootstrap_external>(302): <frozen importlib._bootstrap_external>(303): <frozen importlib._bootstrap_external>(304): <frozen importlib._bootstrap_external>(305): <frozen importlib._bootstrap_external>(308): <frozen importlib._bootstrap_external>(309): <frozen importlib._bootstrap_external>(313):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(811): <frozen importlib._bootstrap_external>(812):  --- modulename: _bootstrap_external, funcname: path_stats
<frozen importlib._bootstrap_external>(953):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(954): <frozen importlib._bootstrap_external>(816): <frozen importlib._bootstrap_external>(817): <frozen importlib._bootstrap_external>(818):  --- modulename: _bootstrap_external, funcname: get_data
<frozen importlib._bootstrap_external>(916): <frozen importlib._bootstrap_external>(917): <frozen importlib._bootstrap_external>(823): <frozen importlib._bootstrap_external>(824): <frozen importlib._bootstrap_external>(826): <frozen importlib._bootstrap_external>(827):  --- modulename: _bootstrap_external, funcname: _classify_pyc
<frozen importlib._bootstrap_external>(454): <frozen importlib._bootstrap_external>(455): <frozen importlib._bootstrap_external>(459): <frozen importlib._bootstrap_external>(463):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(465): <frozen importlib._bootstrap_external>(468): <frozen importlib._bootstrap_external>(828): <frozen importlib._bootstrap_external>(829): <frozen importlib._bootstrap_external>(830): <frozen importlib._bootstrap_external>(843): <frozen importlib._bootstrap_external>(844): <frozen importlib._bootstrap_external>(845): <frozen importlib._bootstrap_external>(846): <frozen importlib._bootstrap_external>(847): <frozen importlib._bootstrap_external>(848):  --- modulename: _bootstrap_external, funcname: _validate_timestamp_pyc
<frozen importlib._bootstrap_external>(490):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(494): <frozen importlib._bootstrap_external>(495):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(853): <frozen importlib._bootstrap_external>(854):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(855): <frozen importlib._bootstrap_external>(856): <frozen importlib._bootstrap_external>(857):  --- modulename: _bootstrap_external, funcname: _compile_bytecode
<frozen importlib._bootstrap_external>(525): <frozen importlib._bootstrap_external>(526): <frozen importlib._bootstrap_external>(527):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(528): <frozen importlib._bootstrap_external>(529): <frozen importlib._bootstrap_external>(530): <frozen importlib._bootstrap_external>(725): <frozen importlib._bootstrap_external>(728):  --- modulename: _bootstrap, funcname: _call_with_frames_removed
<frozen importlib._bootstrap>(219):  --- modulename: process, funcname: <module>
process.py(44): """
process.py(46): __author__ = 'Brian Quinlan (brian@sweetapp.com)'
process.py(48): import atexit
process.py(49): import os
process.py(50): from concurrent.futures import _base
 --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1021): <frozen importlib._bootstrap>(1028): <frozen importlib._bootstrap>(1032): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1044): process.py(51): import queue
process.py(52): from queue import Full
 --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(53): import multiprocessing as mp
process.py(54): from multiprocessing.connection import wait
 --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(55): from multiprocessing.queues import Queue
 --- modulename: _bootstrap, funcname: _find_and_load
<frozen importlib._bootstrap>(980):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(144): <frozen importlib._bootstrap>(145):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(148):  --- modulename: _bootstrap, funcname: _get_module_lock
<frozen importlib._bootstrap>(163): <frozen importlib._bootstrap>(164): <frozen importlib._bootstrap>(165): <frozen importlib._bootstrap>(166): <frozen importlib._bootstrap>(167): <frozen importlib._bootstrap>(168): <frozen importlib._bootstrap>(170): <frozen importlib._bootstrap>(171): <frozen importlib._bootstrap>(174):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(59): <frozen importlib._bootstrap>(60): <frozen importlib._bootstrap>(61): <frozen importlib._bootstrap>(62): <frozen importlib._bootstrap>(63): <frozen importlib._bootstrap>(64): <frozen importlib._bootstrap>(176): <frozen importlib._bootstrap>(187): <frozen importlib._bootstrap>(189): <frozen importlib._bootstrap>(191): <frozen importlib._bootstrap>(149):  --- modulename: _bootstrap, funcname: acquire
<frozen importlib._bootstrap>(84): <frozen importlib._bootstrap>(85): <frozen importlib._bootstrap>(86): <frozen importlib._bootstrap>(87): <frozen importlib._bootstrap>(88): <frozen importlib._bootstrap>(89): <frozen importlib._bootstrap>(90): <frozen importlib._bootstrap>(91): <frozen importlib._bootstrap>(92): <frozen importlib._bootstrap>(101): <frozen importlib._bootstrap>(981): <frozen importlib._bootstrap>(982): <frozen importlib._bootstrap>(983):  --- modulename: _bootstrap, funcname: _find_and_load_unlocked
<frozen importlib._bootstrap>(949): <frozen importlib._bootstrap>(950): <frozen importlib._bootstrap>(951): <frozen importlib._bootstrap>(952): <frozen importlib._bootstrap>(955): <frozen importlib._bootstrap>(957): <frozen importlib._bootstrap>(958): <frozen importlib._bootstrap>(959): <frozen importlib._bootstrap>(963):  --- modulename: _bootstrap, funcname: _find_spec
<frozen importlib._bootstrap>(884): <frozen importlib._bootstrap>(885): <frozen importlib._bootstrap>(890): <frozen importlib._bootstrap>(896): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap, funcname: find_spec
<frozen importlib._bootstrap>(721): <frozen importlib._bootstrap>(722):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap, funcname: find_spec
<frozen importlib._bootstrap>(794): <frozen importlib._bootstrap>(797):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap_external, funcname: find_spec
<frozen importlib._bootstrap_external>(1278): <frozen importlib._bootstrap_external>(1280):  --- modulename: _bootstrap_external, funcname: _get_spec
<frozen importlib._bootstrap_external>(1245): <frozen importlib._bootstrap_external>(1246): <frozen importlib._bootstrap_external>(1247): <frozen importlib._bootstrap_external>(1249):  --- modulename: _bootstrap_external, funcname: _path_importer_cache
<frozen importlib._bootstrap_external>(1211): <frozen importlib._bootstrap_external>(1218): <frozen importlib._bootstrap_external>(1219): <frozen importlib._bootstrap_external>(1223): <frozen importlib._bootstrap_external>(1250): <frozen importlib._bootstrap_external>(1251): <frozen importlib._bootstrap_external>(1252):  --- modulename: _bootstrap_external, funcname: find_spec
<frozen importlib._bootstrap_external>(1361): <frozen importlib._bootstrap_external>(1362): <frozen importlib._bootstrap_external>(1363): <frozen importlib._bootstrap_external>(1364):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(1367): <frozen importlib._bootstrap_external>(1371):  --- modulename: _bootstrap_external, funcname: _relax_case
<frozen importlib._bootstrap_external>(38): <frozen importlib._bootstrap_external>(1375): <frozen importlib._bootstrap_external>(1376): <frozen importlib._bootstrap_external>(1378): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1394):  --- modulename: _bootstrap_external, funcname: _path_isfile
<frozen importlib._bootstrap_external>(95):  --- modulename: _bootstrap_external, funcname: _path_is_mode_type
<frozen importlib._bootstrap_external>(86): <frozen importlib._bootstrap_external>(87):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(90): <frozen importlib._bootstrap_external>(1395): <frozen importlib._bootstrap_external>(1396):  --- modulename: _bootstrap_external, funcname: _get_spec
<frozen importlib._bootstrap_external>(1352):  --- modulename: _bootstrap_external, funcname: __init__
<frozen importlib._bootstrap_external>(887): <frozen importlib._bootstrap_external>(888): <frozen importlib._bootstrap_external>(1353): <frozen importlib._bootstrap_external>(1354):  --- modulename: _bootstrap_external, funcname: spec_from_file_location
<frozen importlib._bootstrap_external>(586): <frozen importlib._bootstrap_external>(598): <frozen importlib._bootstrap_external>(606):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(371): <frozen importlib._bootstrap>(372): <frozen importlib._bootstrap>(373): <frozen importlib._bootstrap>(374): <frozen importlib._bootstrap>(375): <frozen importlib._bootstrap>(378): <frozen importlib._bootstrap>(379): <frozen importlib._bootstrap_external>(607): <frozen importlib._bootstrap_external>(610): <frozen importlib._bootstrap_external>(620): <frozen importlib._bootstrap_external>(631): <frozen importlib._bootstrap_external>(632): <frozen importlib._bootstrap_external>(637): <frozen importlib._bootstrap_external>(1255): <frozen importlib._bootstrap_external>(1257): <frozen importlib._bootstrap_external>(1258): <frozen importlib._bootstrap_external>(1281): <frozen importlib._bootstrap_external>(1283): <frozen importlib._bootstrap_external>(1294):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(909): <frozen importlib._bootstrap>(924): <frozen importlib._bootstrap>(964): <frozen importlib._bootstrap>(967):  --- modulename: _bootstrap, funcname: _load_unlocked
<frozen importlib._bootstrap>(665): <frozen importlib._bootstrap>(667): <frozen importlib._bootstrap>(670):  --- modulename: _bootstrap, funcname: module_from_spec
<frozen importlib._bootstrap>(579): <frozen importlib._bootstrap>(580): <frozen importlib._bootstrap>(583):  --- modulename: _bootstrap_external, funcname: create_module
<frozen importlib._bootstrap_external>(720): <frozen importlib._bootstrap>(587): <frozen importlib._bootstrap>(588):  --- modulename: _bootstrap, funcname: _new_module
<frozen importlib._bootstrap>(36): <frozen importlib._bootstrap>(589):  --- modulename: _bootstrap, funcname: _init_module_attrs
<frozen importlib._bootstrap>(508): <frozen importlib._bootstrap>(514): <frozen importlib._bootstrap>(515): <frozen importlib._bootstrap>(516): <frozen importlib._bootstrap>(537): <frozen importlib._bootstrap>(538): <frozen importlib._bootstrap>(542): <frozen importlib._bootstrap>(543): <frozen importlib._bootstrap>(544):  --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420): <frozen importlib._bootstrap>(548): <frozen importlib._bootstrap>(549): <frozen importlib._bootstrap>(553): <frozen importlib._bootstrap>(554): <frozen importlib._bootstrap>(560):  --- modulename: _bootstrap, funcname: has_location
<frozen importlib._bootstrap>(426): <frozen importlib._bootstrap>(561): <frozen importlib._bootstrap>(562): <frozen importlib._bootstrap>(563): <frozen importlib._bootstrap>(567): <frozen importlib._bootstrap>(568):  --- modulename: _bootstrap, funcname: cached
<frozen importlib._bootstrap>(405): <frozen importlib._bootstrap>(406): <frozen importlib._bootstrap>(407): <frozen importlib._bootstrap>(409):  --- modulename: _bootstrap_external, funcname: _get_cached
<frozen importlib._bootstrap_external>(370): <frozen importlib._bootstrap_external>(371): <frozen importlib._bootstrap_external>(372):  --- modulename: _bootstrap_external, funcname: cache_from_source
<frozen importlib._bootstrap_external>(289): <frozen importlib._bootstrap_external>(296): <frozen importlib._bootstrap_external>(297):  --- modulename: _bootstrap_external, funcname: _path_split
<frozen importlib._bootstrap_external>(64): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(69): <frozen importlib._bootstrap_external>(70): <frozen importlib._bootstrap_external>(298): <frozen importlib._bootstrap_external>(299): <frozen importlib._bootstrap_external>(300): <frozen importlib._bootstrap_external>(302): <frozen importlib._bootstrap_external>(303): <frozen importlib._bootstrap_external>(304): <frozen importlib._bootstrap_external>(305): <frozen importlib._bootstrap_external>(308): <frozen importlib._bootstrap_external>(309): <frozen importlib._bootstrap_external>(313):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap>(410): <frozen importlib._bootstrap>(569): <frozen importlib._bootstrap>(570):  --- modulename: _bootstrap, funcname: cached
<frozen importlib._bootstrap>(405): <frozen importlib._bootstrap>(410): <frozen importlib._bootstrap>(573): <frozen importlib._bootstrap>(590): <frozen importlib._bootstrap>(671):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(308): <frozen importlib._bootstrap>(309):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(315): <frozen importlib._bootstrap>(316): <frozen importlib._bootstrap>(672): <frozen importlib._bootstrap>(677):  --- modulename: _bootstrap_external, funcname: exec_module
<frozen importlib._bootstrap_external>(724):  --- modulename: _bootstrap_external, funcname: get_code
<frozen importlib._bootstrap_external>(800):  --- modulename: _bootstrap_external, funcname: _check_name_wrapper
<frozen importlib._bootstrap_external>(402): <frozen importlib._bootstrap_external>(404): <frozen importlib._bootstrap_external>(407):  --- modulename: _bootstrap_external, funcname: get_filename
<frozen importlib._bootstrap_external>(912): <frozen importlib._bootstrap_external>(801): <frozen importlib._bootstrap_external>(802): <frozen importlib._bootstrap_external>(803): <frozen importlib._bootstrap_external>(804): <frozen importlib._bootstrap_external>(805): <frozen importlib._bootstrap_external>(806): <frozen importlib._bootstrap_external>(807):  --- modulename: _bootstrap_external, funcname: cache_from_source
<frozen importlib._bootstrap_external>(289): <frozen importlib._bootstrap_external>(296): <frozen importlib._bootstrap_external>(297):  --- modulename: _bootstrap_external, funcname: _path_split
<frozen importlib._bootstrap_external>(64): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(69): <frozen importlib._bootstrap_external>(70): <frozen importlib._bootstrap_external>(298): <frozen importlib._bootstrap_external>(299): <frozen importlib._bootstrap_external>(300): <frozen importlib._bootstrap_external>(302): <frozen importlib._bootstrap_external>(303): <frozen importlib._bootstrap_external>(304): <frozen importlib._bootstrap_external>(305): <frozen importlib._bootstrap_external>(308): <frozen importlib._bootstrap_external>(309): <frozen importlib._bootstrap_external>(313):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(811): <frozen importlib._bootstrap_external>(812):  --- modulename: _bootstrap_external, funcname: path_stats
<frozen importlib._bootstrap_external>(953):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(954): <frozen importlib._bootstrap_external>(816): <frozen importlib._bootstrap_external>(817): <frozen importlib._bootstrap_external>(818):  --- modulename: _bootstrap_external, funcname: get_data
<frozen importlib._bootstrap_external>(916): <frozen importlib._bootstrap_external>(917): <frozen importlib._bootstrap_external>(823): <frozen importlib._bootstrap_external>(824): <frozen importlib._bootstrap_external>(826): <frozen importlib._bootstrap_external>(827):  --- modulename: _bootstrap_external, funcname: _classify_pyc
<frozen importlib._bootstrap_external>(454): <frozen importlib._bootstrap_external>(455): <frozen importlib._bootstrap_external>(459): <frozen importlib._bootstrap_external>(463):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(465): <frozen importlib._bootstrap_external>(468): <frozen importlib._bootstrap_external>(828): <frozen importlib._bootstrap_external>(829): <frozen importlib._bootstrap_external>(830): <frozen importlib._bootstrap_external>(843): <frozen importlib._bootstrap_external>(844): <frozen importlib._bootstrap_external>(845): <frozen importlib._bootstrap_external>(846): <frozen importlib._bootstrap_external>(847): <frozen importlib._bootstrap_external>(848):  --- modulename: _bootstrap_external, funcname: _validate_timestamp_pyc
<frozen importlib._bootstrap_external>(490):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(494): <frozen importlib._bootstrap_external>(495):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(853): <frozen importlib._bootstrap_external>(854):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(855): <frozen importlib._bootstrap_external>(856): <frozen importlib._bootstrap_external>(857):  --- modulename: _bootstrap_external, funcname: _compile_bytecode
<frozen importlib._bootstrap_external>(525): <frozen importlib._bootstrap_external>(526): <frozen importlib._bootstrap_external>(527):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(528): <frozen importlib._bootstrap_external>(529): <frozen importlib._bootstrap_external>(530): <frozen importlib._bootstrap_external>(725): <frozen importlib._bootstrap_external>(728):  --- modulename: _bootstrap, funcname: _call_with_frames_removed
<frozen importlib._bootstrap>(219):  --- modulename: queues, funcname: <module>
queues.py(10): __all__ = ['Queue', 'SimpleQueue', 'JoinableQueue']
queues.py(12): import sys
queues.py(13): import os
queues.py(14): import threading
queues.py(15): import collections
queues.py(16): import time
queues.py(17): import weakref
queues.py(18): import errno
queues.py(20): from queue import Empty, Full
 --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): queues.py(22): import _multiprocessing
queues.py(24): from . import connection
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1021): <frozen importlib._bootstrap>(1028): <frozen importlib._bootstrap>(1032): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1044): queues.py(25): from . import context
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1021): <frozen importlib._bootstrap>(1028): <frozen importlib._bootstrap>(1032): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1044): queues.py(26): _ForkingPickler = context.reduction.ForkingPickler
queues.py(28): from .util import debug, info, Finalize, register_after_fork, is_exiting
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): queues.py(34): class Queue(object):
 --- modulename: queues, funcname: Queue
queues.py(34): class Queue(object):
queues.py(36):     def __init__(self, maxsize=0, *, ctx):
queues.py(57):     def __getstate__(self):
queues.py(62):     def __setstate__(self, state):
queues.py(67):     def _after_fork(self):
queues.py(80):     def put(self, obj, block=True, timeout=None):
queues.py(91):     def get(self, block=True, timeout=None):
queues.py(115):     def qsize(self):
queues.py(119):     def empty(self):
queues.py(122):     def full(self):
queues.py(125):     def get_nowait(self):
queues.py(128):     def put_nowait(self, obj):
queues.py(131):     def close(self):
queues.py(141):     def join_thread(self):
queues.py(147):     def cancel_join_thread(self):
queues.py(155):     def _start_thread(self):
queues.py(187):     @staticmethod
queues.py(197):     @staticmethod
queues.py(204):     @staticmethod
queues.py(266):     @staticmethod
queues.py(276): _sentinel = object()
queues.py(286): class JoinableQueue(Queue):
 --- modulename: queues, funcname: JoinableQueue
queues.py(286): class JoinableQueue(Queue):
queues.py(288):     def __init__(self, maxsize=0, *, ctx):
queues.py(293):     def __getstate__(self):
queues.py(296):     def __setstate__(self, state):
queues.py(300):     def put(self, obj, block=True, timeout=None):
queues.py(312):     def task_done(self):
queues.py(319):     def join(self):
queues.py(328): class SimpleQueue(object):
 --- modulename: queues, funcname: SimpleQueue
queues.py(328): class SimpleQueue(object):
queues.py(330):     def __init__(self, *, ctx):
queues.py(339):     def empty(self):
queues.py(342):     def __getstate__(self):
queues.py(346):     def __setstate__(self, state):
queues.py(350):     def get(self):
queues.py(356):     def put(self, obj):
 --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(319): <frozen importlib._bootstrap>(320): <frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321): <frozen importlib._bootstrap>(327):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap>(329): <frozen importlib._bootstrap>(682): <frozen importlib._bootstrap>(968): <frozen importlib._bootstrap>(970): <frozen importlib._bootstrap>(971): <frozen importlib._bootstrap>(972):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(152):  --- modulename: _bootstrap, funcname: release
<frozen importlib._bootstrap>(104): <frozen importlib._bootstrap>(105): <frozen importlib._bootstrap>(106): <frozen importlib._bootstrap>(108): <frozen importlib._bootstrap>(109): <frozen importlib._bootstrap>(110): <frozen importlib._bootstrap>(111): <frozen importlib._bootstrap>(112):  --- modulename: _bootstrap, funcname: cb
<frozen importlib._bootstrap>(177): <frozen importlib._bootstrap>(178): <frozen importlib._bootstrap>(182): <frozen importlib._bootstrap>(183): <frozen importlib._bootstrap>(185):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(56): import threading
process.py(57): import weakref
process.py(58): from functools import partial
 --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(59): import itertools
process.py(60): import sys
process.py(61): import traceback
process.py(77): _threads_wakeups = weakref.WeakKeyDictionary()
 --- modulename: weakref, funcname: __init__
weakref.py(357):         self.data = {}
weakref.py(358):         def remove(k, selfref=ref(self)):
weakref.py(365):         self._remove = remove
weakref.py(367):         self._pending_removals = []
weakref.py(368):         self._iterating = set()
weakref.py(369):         self._dirty_len = False
weakref.py(370):         if dict is not None:
process.py(78): _global_shutdown = False
process.py(81): class _ThreadWakeup:
 --- modulename: process, funcname: _ThreadWakeup
process.py(81): class _ThreadWakeup:
process.py(82):     def __init__(self):
process.py(85):     def close(self):
process.py(89):     def wakeup(self):
process.py(92):     def clear(self):
process.py(97): def _python_exit():
process.py(110): EXTRA_QUEUED_CALLS = 1
process.py(117): _MAX_WINDOWS_WORKERS = 63 - 2
process.py(121): class _RemoteTraceback(Exception):
 --- modulename: process, funcname: _RemoteTraceback
process.py(121): class _RemoteTraceback(Exception):
process.py(122):     def __init__(self, tb):
process.py(124):     def __str__(self):
process.py(127): class _ExceptionWithTraceback:
 --- modulename: process, funcname: _ExceptionWithTraceback
process.py(127): class _ExceptionWithTraceback:
process.py(128):     def __init__(self, exc, tb):
process.py(133):     def __reduce__(self):
process.py(136): def _rebuild_exc(exc, tb):
process.py(140): class _WorkItem(object):
 --- modulename: process, funcname: _WorkItem
process.py(140): class _WorkItem(object):
process.py(141):     def __init__(self, future, fn, args, kwargs):
process.py(147): class _ResultItem(object):
 --- modulename: process, funcname: _ResultItem
process.py(147): class _ResultItem(object):
process.py(148):     def __init__(self, work_id, exception=None, result=None):
process.py(153): class _CallItem(object):
 --- modulename: process, funcname: _CallItem
process.py(153): class _CallItem(object):
process.py(154):     def __init__(self, work_id, fn, args, kwargs):
process.py(161): class _SafeQueue(Queue):
 --- modulename: process, funcname: _SafeQueue
process.py(161): class _SafeQueue(Queue):
process.py(162):     """Safe Queue set exception to the future object linked to a job"""
process.py(163):     def __init__(self, max_size=0, *, ctx, pending_work_items):
process.py(167):     def _on_queue_feeder_error(self, e, obj):
process.py(180): def _get_chunks(*iterables, chunksize):
process.py(189): def _process_chunk(fn, chunk):
process.py(201): def _sendback_result(result_queue, work_id, result=None, exception=None):
process.py(211): def _process_worker(call_queue, result_queue, initializer, initargs):
process.py(251): def _add_call_item_to_queue(pending_work_items,
process.py(289): def _queue_management_worker(executor_reference,
process.py(449): _system_limits_checked = False
process.py(450): _system_limited = None
process.py(453): def _check_system_limits():
process.py(477): def _chain_from_iterable_of_lists(iterable):
process.py(489): class BrokenProcessPool(_base.BrokenExecutor):
 --- modulename: process, funcname: BrokenProcessPool
process.py(489): class BrokenProcessPool(_base.BrokenExecutor):
process.py(493):     """
process.py(496): class ProcessPoolExecutor(_base.Executor):
 --- modulename: process, funcname: ProcessPoolExecutor
process.py(496): class ProcessPoolExecutor(_base.Executor):
process.py(498):                  initializer=None, initargs=()):
process.py(572):     def _start_queue_management_thread(self):
process.py(599):     def _adjust_process_count(self):
process.py(610):     def submit(*args, **kwargs):
process.py(643):     submit.__doc__ = _base.Executor.submit.__doc__
process.py(645):     def map(self, fn, *iterables, timeout=None, chunksize=1):
process.py(674):     def shutdown(self, wait=True):
process.py(697):     shutdown.__doc__ = _base.Executor.shutdown.__doc__
process.py(699): atexit.register(_python_exit)
 --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(319): <frozen importlib._bootstrap>(320): <frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321): <frozen importlib._bootstrap>(327):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap>(329): <frozen importlib._bootstrap>(682): <frozen importlib._bootstrap>(968): <frozen importlib._bootstrap>(970): <frozen importlib._bootstrap>(971): <frozen importlib._bootstrap>(972):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(152):  --- modulename: _bootstrap, funcname: release
<frozen importlib._bootstrap>(104): <frozen importlib._bootstrap>(105): <frozen importlib._bootstrap>(106): <frozen importlib._bootstrap>(108): <frozen importlib._bootstrap>(109): <frozen importlib._bootstrap>(110): <frozen importlib._bootstrap>(111): <frozen importlib._bootstrap>(112):  --- modulename: _bootstrap, funcname: cb
<frozen importlib._bootstrap>(177): <frozen importlib._bootstrap>(178): <frozen importlib._bootstrap>(182): <frozen importlib._bootstrap>(183): <frozen importlib._bootstrap>(185):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): __init__.py(44):         ProcessPoolExecutor = pe
__init__.py(45):         return pe
 --- modulename: process, funcname: __init__
process.py(510):         _check_system_limits()
 --- modulename: process, funcname: _check_system_limits
process.py(455):     if _system_limits_checked:
process.py(458):     _system_limits_checked = True
process.py(459):     try:
process.py(460):         nsems_max = os.sysconf("SC_SEM_NSEMS_MAX")
process.py(461):     except (AttributeError, ValueError):
process.py(463):         return
process.py(512):         if max_workers is None:
process.py(513):             self._max_workers = os.cpu_count() or 1
process.py(514):             if sys.platform == 'win32':
process.py(515):                 self._max_workers = min(_MAX_WINDOWS_WORKERS,
process.py(516):                                         self._max_workers)
process.py(527):         if mp_context is None:
process.py(528):             mp_context = mp.get_context()
 --- modulename: context, funcname: get_context
context.py(233):         if method is None:
context.py(234):             if self._actual_context is None:
context.py(236):             return self._actual_context
process.py(529):         self._mp_context = mp_context
process.py(531):         if initializer is not None and not callable(initializer):
process.py(533):         self._initializer = initializer
process.py(534):         self._initargs = initargs
process.py(537):         self._queue_management_thread = None
process.py(540):         self._processes = {}
process.py(543):         self._shutdown_thread = False
process.py(544):         self._shutdown_lock = threading.Lock()
process.py(545):         self._broken = False
process.py(546):         self._queue_count = 0
process.py(547):         self._pending_work_items = {}
process.py(553):         queue_size = self._max_workers + EXTRA_QUEUED_CALLS
process.py(554):         self._call_queue = _SafeQueue(
process.py(555):             max_size=queue_size, ctx=self._mp_context,
process.py(556):             pending_work_items=self._pending_work_items)
 --- modulename: process, funcname: __init__
process.py(164):         self.pending_work_items = pending_work_items
process.py(165):         super().__init__(max_size, ctx=ctx)
 --- modulename: queues, funcname: __init__
queues.py(37):         if maxsize <= 0:
queues.py(40):         self._maxsize = maxsize
queues.py(41):         self._reader, self._writer = connection.Pipe(duplex=False)
 --- modulename: connection, funcname: Pipe
connection.py(529):         address = arbitrary_address('AF_PIPE')
 --- modulename: connection, funcname: arbitrary_address
connection.py(73):     if family == 'AF_INET':
connection.py(75):     elif family == 'AF_UNIX':
connection.py(77):     elif family == 'AF_PIPE':
connection.py(78):         return tempfile.mktemp(prefix=r'\\.\pipe\pyc-%d-%d-' %
connection.py(79):                                (os.getpid(), next(_mmap_counter)), dir="")
 --- modulename: tempfile, funcname: mktemp
tempfile.py(400):     if dir is None:
tempfile.py(403):     names = _get_candidate_names()
 --- modulename: tempfile, funcname: _get_candidate_names
tempfile.py(237):     if _name_sequence is None:
tempfile.py(244):     return _name_sequence
tempfile.py(404):     for seq in range(TMP_MAX):
tempfile.py(405):         name = next(names)
 --- modulename: tempfile, funcname: __next__
tempfile.py(154):         c = self.characters
tempfile.py(155):         choose = self.rng.choice
 --- modulename: tempfile, funcname: rng
tempfile.py(144):         cur_pid = _os.getpid()
tempfile.py(145):         if cur_pid != getattr(self, '_rng_pid', None):
tempfile.py(148):         return self._rng
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: tempfile, funcname: <listcomp>
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
tempfile.py(157):         return ''.join(letters)
tempfile.py(406):         file = _os.path.join(dir, prefix + name + suffix)
 --- modulename: ntpath, funcname: join
ntpath.py(76):     path = os.fspath(path)
ntpath.py(77):     if isinstance(path, bytes):
ntpath.py(82):         sep = '\\'
ntpath.py(83):         seps = '\\/'
ntpath.py(84):         colon = ':'
ntpath.py(85):     try:
ntpath.py(86):         if not paths:
ntpath.py(88):         result_drive, result_path = splitdrive(path)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(170):     return p[:0], p
ntpath.py(89):         for p in map(os.fspath, paths):
ntpath.py(90):             p_drive, p_path = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(157):             index = normp.find(sep, 2)
ntpath.py(158):             if index == -1:
ntpath.py(160):             index2 = normp.find(sep, index + 1)
ntpath.py(163):             if index2 == index + 1:
ntpath.py(165):             if index2 == -1:
ntpath.py(167):             return p[:index2], p[index2:]
ntpath.py(91):             if p_path and p_path[0] in seps:
ntpath.py(93):                 if p_drive or not result_drive:
ntpath.py(94):                     result_drive = p_drive
ntpath.py(95):                 result_path = p_path
ntpath.py(96):                 continue
ntpath.py(89):         for p in map(os.fspath, paths):
ntpath.py(110):         if (result_path and result_path[0] not in seps and
ntpath.py(113):         return result_drive + result_path
tempfile.py(407):         if not _exists(file):
 --- modulename: tempfile, funcname: _exists
tempfile.py(85):     try:
tempfile.py(86):         _stat(fn)
tempfile.py(87):     except OSError:
tempfile.py(88):         return False
tempfile.py(408):             return file
connection.py(530):         if duplex:
connection.py(535):             openmode = _winapi.PIPE_ACCESS_INBOUND
connection.py(536):             access = _winapi.GENERIC_WRITE
connection.py(537):             obsize, ibsize = 0, BUFSIZE
connection.py(539):         h1 = _winapi.CreateNamedPipe(
connection.py(540):             address, openmode | _winapi.FILE_FLAG_OVERLAPPED |
connection.py(541):             _winapi.FILE_FLAG_FIRST_PIPE_INSTANCE,
connection.py(542):             _winapi.PIPE_TYPE_MESSAGE | _winapi.PIPE_READMODE_MESSAGE |
connection.py(543):             _winapi.PIPE_WAIT,
connection.py(544):             1, obsize, ibsize, _winapi.NMPWAIT_WAIT_FOREVER,
connection.py(546):             _winapi.NULL
connection.py(548):         h2 = _winapi.CreateFile(
connection.py(549):             address, access, 0, _winapi.NULL, _winapi.OPEN_EXISTING,
connection.py(550):             _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL
connection.py(552):         _winapi.SetNamedPipeHandleState(
connection.py(553):             h2, _winapi.PIPE_READMODE_MESSAGE, None, None
connection.py(556):         overlapped = _winapi.ConnectNamedPipe(h1, overlapped=True)
connection.py(557):         _, err = overlapped.GetOverlappedResult(True)
connection.py(558):         assert err == 0
connection.py(560):         c1 = PipeConnection(h1, writable=duplex)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(561):         c2 = PipeConnection(h2, readable=duplex)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(563):         return c1, c2
queues.py(42):         self._rlock = ctx.Lock()
 --- modulename: context, funcname: Lock
context.py(66):         from .synchronize import Lock
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _find_and_load
<frozen importlib._bootstrap>(980):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(144): <frozen importlib._bootstrap>(145):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(148):  --- modulename: _bootstrap, funcname: _get_module_lock
<frozen importlib._bootstrap>(163): <frozen importlib._bootstrap>(164): <frozen importlib._bootstrap>(165): <frozen importlib._bootstrap>(166): <frozen importlib._bootstrap>(167): <frozen importlib._bootstrap>(168): <frozen importlib._bootstrap>(170): <frozen importlib._bootstrap>(171): <frozen importlib._bootstrap>(174):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(59): <frozen importlib._bootstrap>(60): <frozen importlib._bootstrap>(61): <frozen importlib._bootstrap>(62): <frozen importlib._bootstrap>(63): <frozen importlib._bootstrap>(64): <frozen importlib._bootstrap>(176): <frozen importlib._bootstrap>(187): <frozen importlib._bootstrap>(189): <frozen importlib._bootstrap>(191): <frozen importlib._bootstrap>(149):  --- modulename: _bootstrap, funcname: acquire
<frozen importlib._bootstrap>(84): <frozen importlib._bootstrap>(85): <frozen importlib._bootstrap>(86): <frozen importlib._bootstrap>(87): <frozen importlib._bootstrap>(88): <frozen importlib._bootstrap>(89): <frozen importlib._bootstrap>(90): <frozen importlib._bootstrap>(91): <frozen importlib._bootstrap>(92): <frozen importlib._bootstrap>(101): <frozen importlib._bootstrap>(981): <frozen importlib._bootstrap>(982): <frozen importlib._bootstrap>(983):  --- modulename: _bootstrap, funcname: _find_and_load_unlocked
<frozen importlib._bootstrap>(949): <frozen importlib._bootstrap>(950): <frozen importlib._bootstrap>(951): <frozen importlib._bootstrap>(952): <frozen importlib._bootstrap>(955): <frozen importlib._bootstrap>(957): <frozen importlib._bootstrap>(958): <frozen importlib._bootstrap>(959): <frozen importlib._bootstrap>(963):  --- modulename: _bootstrap, funcname: _find_spec
<frozen importlib._bootstrap>(884): <frozen importlib._bootstrap>(885): <frozen importlib._bootstrap>(890): <frozen importlib._bootstrap>(896): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap, funcname: find_spec
<frozen importlib._bootstrap>(721): <frozen importlib._bootstrap>(722):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap, funcname: find_spec
<frozen importlib._bootstrap>(794): <frozen importlib._bootstrap>(797):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(897): <frozen importlib._bootstrap>(898):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(857): <frozen importlib._bootstrap>(899): <frozen importlib._bootstrap>(900): <frozen importlib._bootstrap>(906):  --- modulename: _bootstrap_external, funcname: find_spec
<frozen importlib._bootstrap_external>(1278): <frozen importlib._bootstrap_external>(1280):  --- modulename: _bootstrap_external, funcname: _get_spec
<frozen importlib._bootstrap_external>(1245): <frozen importlib._bootstrap_external>(1246): <frozen importlib._bootstrap_external>(1247): <frozen importlib._bootstrap_external>(1249):  --- modulename: _bootstrap_external, funcname: _path_importer_cache
<frozen importlib._bootstrap_external>(1211): <frozen importlib._bootstrap_external>(1218): <frozen importlib._bootstrap_external>(1219): <frozen importlib._bootstrap_external>(1223): <frozen importlib._bootstrap_external>(1250): <frozen importlib._bootstrap_external>(1251): <frozen importlib._bootstrap_external>(1252):  --- modulename: _bootstrap_external, funcname: find_spec
<frozen importlib._bootstrap_external>(1361): <frozen importlib._bootstrap_external>(1362): <frozen importlib._bootstrap_external>(1363): <frozen importlib._bootstrap_external>(1364):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(1367): <frozen importlib._bootstrap_external>(1371):  --- modulename: _bootstrap_external, funcname: _relax_case
<frozen importlib._bootstrap_external>(38): <frozen importlib._bootstrap_external>(1375): <frozen importlib._bootstrap_external>(1376): <frozen importlib._bootstrap_external>(1378): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1390): <frozen importlib._bootstrap_external>(1391):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(1392):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(1393): <frozen importlib._bootstrap_external>(1394):  --- modulename: _bootstrap_external, funcname: _path_isfile
<frozen importlib._bootstrap_external>(95):  --- modulename: _bootstrap_external, funcname: _path_is_mode_type
<frozen importlib._bootstrap_external>(86): <frozen importlib._bootstrap_external>(87):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(90): <frozen importlib._bootstrap_external>(1395): <frozen importlib._bootstrap_external>(1396):  --- modulename: _bootstrap_external, funcname: _get_spec
<frozen importlib._bootstrap_external>(1352):  --- modulename: _bootstrap_external, funcname: __init__
<frozen importlib._bootstrap_external>(887): <frozen importlib._bootstrap_external>(888): <frozen importlib._bootstrap_external>(1353): <frozen importlib._bootstrap_external>(1354):  --- modulename: _bootstrap_external, funcname: spec_from_file_location
<frozen importlib._bootstrap_external>(586): <frozen importlib._bootstrap_external>(598): <frozen importlib._bootstrap_external>(606):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(371): <frozen importlib._bootstrap>(372): <frozen importlib._bootstrap>(373): <frozen importlib._bootstrap>(374): <frozen importlib._bootstrap>(375): <frozen importlib._bootstrap>(378): <frozen importlib._bootstrap>(379): <frozen importlib._bootstrap_external>(607): <frozen importlib._bootstrap_external>(610): <frozen importlib._bootstrap_external>(620): <frozen importlib._bootstrap_external>(631): <frozen importlib._bootstrap_external>(632): <frozen importlib._bootstrap_external>(637): <frozen importlib._bootstrap_external>(1255): <frozen importlib._bootstrap_external>(1257): <frozen importlib._bootstrap_external>(1258): <frozen importlib._bootstrap_external>(1281): <frozen importlib._bootstrap_external>(1283): <frozen importlib._bootstrap_external>(1294):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(861): <frozen importlib._bootstrap>(907): <frozen importlib._bootstrap>(909): <frozen importlib._bootstrap>(924): <frozen importlib._bootstrap>(964): <frozen importlib._bootstrap>(967):  --- modulename: _bootstrap, funcname: _load_unlocked
<frozen importlib._bootstrap>(665): <frozen importlib._bootstrap>(667): <frozen importlib._bootstrap>(670):  --- modulename: _bootstrap, funcname: module_from_spec
<frozen importlib._bootstrap>(579): <frozen importlib._bootstrap>(580): <frozen importlib._bootstrap>(583):  --- modulename: _bootstrap_external, funcname: create_module
<frozen importlib._bootstrap_external>(720): <frozen importlib._bootstrap>(587): <frozen importlib._bootstrap>(588):  --- modulename: _bootstrap, funcname: _new_module
<frozen importlib._bootstrap>(36): <frozen importlib._bootstrap>(589):  --- modulename: _bootstrap, funcname: _init_module_attrs
<frozen importlib._bootstrap>(508): <frozen importlib._bootstrap>(514): <frozen importlib._bootstrap>(515): <frozen importlib._bootstrap>(516): <frozen importlib._bootstrap>(537): <frozen importlib._bootstrap>(538): <frozen importlib._bootstrap>(542): <frozen importlib._bootstrap>(543): <frozen importlib._bootstrap>(544):  --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420): <frozen importlib._bootstrap>(548): <frozen importlib._bootstrap>(549): <frozen importlib._bootstrap>(553): <frozen importlib._bootstrap>(554): <frozen importlib._bootstrap>(560):  --- modulename: _bootstrap, funcname: has_location
<frozen importlib._bootstrap>(426): <frozen importlib._bootstrap>(561): <frozen importlib._bootstrap>(562): <frozen importlib._bootstrap>(563): <frozen importlib._bootstrap>(567): <frozen importlib._bootstrap>(568):  --- modulename: _bootstrap, funcname: cached
<frozen importlib._bootstrap>(405): <frozen importlib._bootstrap>(406): <frozen importlib._bootstrap>(407): <frozen importlib._bootstrap>(409):  --- modulename: _bootstrap_external, funcname: _get_cached
<frozen importlib._bootstrap_external>(370): <frozen importlib._bootstrap_external>(371): <frozen importlib._bootstrap_external>(372):  --- modulename: _bootstrap_external, funcname: cache_from_source
<frozen importlib._bootstrap_external>(289): <frozen importlib._bootstrap_external>(296): <frozen importlib._bootstrap_external>(297):  --- modulename: _bootstrap_external, funcname: _path_split
<frozen importlib._bootstrap_external>(64): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(69): <frozen importlib._bootstrap_external>(70): <frozen importlib._bootstrap_external>(298): <frozen importlib._bootstrap_external>(299): <frozen importlib._bootstrap_external>(300): <frozen importlib._bootstrap_external>(302): <frozen importlib._bootstrap_external>(303): <frozen importlib._bootstrap_external>(304): <frozen importlib._bootstrap_external>(305): <frozen importlib._bootstrap_external>(308): <frozen importlib._bootstrap_external>(309): <frozen importlib._bootstrap_external>(313):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap>(410): <frozen importlib._bootstrap>(569): <frozen importlib._bootstrap>(570):  --- modulename: _bootstrap, funcname: cached
<frozen importlib._bootstrap>(405): <frozen importlib._bootstrap>(410): <frozen importlib._bootstrap>(573): <frozen importlib._bootstrap>(590): <frozen importlib._bootstrap>(671):  --- modulename: _bootstrap, funcname: __init__
<frozen importlib._bootstrap>(308): <frozen importlib._bootstrap>(309):  --- modulename: _bootstrap, funcname: __enter__
<frozen importlib._bootstrap>(315): <frozen importlib._bootstrap>(316): <frozen importlib._bootstrap>(672): <frozen importlib._bootstrap>(677):  --- modulename: _bootstrap_external, funcname: exec_module
<frozen importlib._bootstrap_external>(724):  --- modulename: _bootstrap_external, funcname: get_code
<frozen importlib._bootstrap_external>(800):  --- modulename: _bootstrap_external, funcname: _check_name_wrapper
<frozen importlib._bootstrap_external>(402): <frozen importlib._bootstrap_external>(404): <frozen importlib._bootstrap_external>(407):  --- modulename: _bootstrap_external, funcname: get_filename
<frozen importlib._bootstrap_external>(912): <frozen importlib._bootstrap_external>(801): <frozen importlib._bootstrap_external>(802): <frozen importlib._bootstrap_external>(803): <frozen importlib._bootstrap_external>(804): <frozen importlib._bootstrap_external>(805): <frozen importlib._bootstrap_external>(806): <frozen importlib._bootstrap_external>(807):  --- modulename: _bootstrap_external, funcname: cache_from_source
<frozen importlib._bootstrap_external>(289): <frozen importlib._bootstrap_external>(296): <frozen importlib._bootstrap_external>(297):  --- modulename: _bootstrap_external, funcname: _path_split
<frozen importlib._bootstrap_external>(64): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(67): <frozen importlib._bootstrap_external>(68): <frozen importlib._bootstrap_external>(69): <frozen importlib._bootstrap_external>(70): <frozen importlib._bootstrap_external>(298): <frozen importlib._bootstrap_external>(299): <frozen importlib._bootstrap_external>(300): <frozen importlib._bootstrap_external>(302): <frozen importlib._bootstrap_external>(303): <frozen importlib._bootstrap_external>(304): <frozen importlib._bootstrap_external>(305): <frozen importlib._bootstrap_external>(308): <frozen importlib._bootstrap_external>(309): <frozen importlib._bootstrap_external>(313):  --- modulename: _bootstrap_external, funcname: _path_join
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(59):  --- modulename: _bootstrap_external, funcname: <listcomp>
<frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(58): <frozen importlib._bootstrap_external>(811): <frozen importlib._bootstrap_external>(812):  --- modulename: _bootstrap_external, funcname: path_stats
<frozen importlib._bootstrap_external>(953):  --- modulename: _bootstrap_external, funcname: _path_stat
<frozen importlib._bootstrap_external>(81): <frozen importlib._bootstrap_external>(954): <frozen importlib._bootstrap_external>(816): <frozen importlib._bootstrap_external>(817): <frozen importlib._bootstrap_external>(818):  --- modulename: _bootstrap_external, funcname: get_data
<frozen importlib._bootstrap_external>(916): <frozen importlib._bootstrap_external>(917): <frozen importlib._bootstrap_external>(823): <frozen importlib._bootstrap_external>(824): <frozen importlib._bootstrap_external>(826): <frozen importlib._bootstrap_external>(827):  --- modulename: _bootstrap_external, funcname: _classify_pyc
<frozen importlib._bootstrap_external>(454): <frozen importlib._bootstrap_external>(455): <frozen importlib._bootstrap_external>(459): <frozen importlib._bootstrap_external>(463):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(465): <frozen importlib._bootstrap_external>(468): <frozen importlib._bootstrap_external>(828): <frozen importlib._bootstrap_external>(829): <frozen importlib._bootstrap_external>(830): <frozen importlib._bootstrap_external>(843): <frozen importlib._bootstrap_external>(844): <frozen importlib._bootstrap_external>(845): <frozen importlib._bootstrap_external>(846): <frozen importlib._bootstrap_external>(847): <frozen importlib._bootstrap_external>(848):  --- modulename: _bootstrap_external, funcname: _validate_timestamp_pyc
<frozen importlib._bootstrap_external>(490):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(494): <frozen importlib._bootstrap_external>(495):  --- modulename: _bootstrap_external, funcname: _r_long
<frozen importlib._bootstrap_external>(53): <frozen importlib._bootstrap_external>(853): <frozen importlib._bootstrap_external>(854):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(855): <frozen importlib._bootstrap_external>(856): <frozen importlib._bootstrap_external>(857):  --- modulename: _bootstrap_external, funcname: _compile_bytecode
<frozen importlib._bootstrap_external>(525): <frozen importlib._bootstrap_external>(526): <frozen importlib._bootstrap_external>(527):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap_external>(528): <frozen importlib._bootstrap_external>(529): <frozen importlib._bootstrap_external>(530): <frozen importlib._bootstrap_external>(725): <frozen importlib._bootstrap_external>(728):  --- modulename: _bootstrap, funcname: _call_with_frames_removed
<frozen importlib._bootstrap>(219):  --- modulename: synchronize, funcname: <module>
synchronize.py(11):     'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition', 'Event'
synchronize.py(14): import threading
synchronize.py(15): import sys
synchronize.py(16): import tempfile
synchronize.py(17): import _multiprocessing
synchronize.py(18): import time
synchronize.py(20): from . import context
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1021): <frozen importlib._bootstrap>(1028): <frozen importlib._bootstrap>(1032): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1044): synchronize.py(21): from . import process
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1021): <frozen importlib._bootstrap>(1028): <frozen importlib._bootstrap>(1032): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1044): synchronize.py(22): from . import util
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1021): <frozen importlib._bootstrap>(1028): <frozen importlib._bootstrap>(1032): <frozen importlib._bootstrap>(1020): <frozen importlib._bootstrap>(1044): synchronize.py(27): try:
synchronize.py(28):     from _multiprocessing import SemLock, sem_unlink
 --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): synchronize.py(39): RECURSIVE_MUTEX, SEMAPHORE = list(range(2))
synchronize.py(40): SEM_VALUE_MAX = _multiprocessing.SemLock.SEM_VALUE_MAX
synchronize.py(46): class SemLock(object):
 --- modulename: synchronize, funcname: SemLock
synchronize.py(46): class SemLock(object):
synchronize.py(48):     _rand = tempfile._RandomNameSequence()
synchronize.py(50):     def __init__(self, kind, value, maxvalue, *, ctx):
synchronize.py(84):     @staticmethod
synchronize.py(90):     def _make_methods(self):
synchronize.py(94):     def __enter__(self):
synchronize.py(97):     def __exit__(self, *args):
synchronize.py(100):     def __getstate__(self):
synchronize.py(109):     def __setstate__(self, state):
synchronize.py(114):     @staticmethod
synchronize.py(123): class Semaphore(SemLock):
 --- modulename: synchronize, funcname: Semaphore
synchronize.py(123): class Semaphore(SemLock):
synchronize.py(125):     def __init__(self, value=1, *, ctx):
synchronize.py(128):     def get_value(self):
synchronize.py(131):     def __repr__(self):
synchronize.py(142): class BoundedSemaphore(Semaphore):
 --- modulename: synchronize, funcname: BoundedSemaphore
synchronize.py(142): class BoundedSemaphore(Semaphore):
synchronize.py(144):     def __init__(self, value=1, *, ctx):
synchronize.py(147):     def __repr__(self):
synchronize.py(159): class Lock(SemLock):
 --- modulename: synchronize, funcname: Lock
synchronize.py(159): class Lock(SemLock):
synchronize.py(161):     def __init__(self, *, ctx):
synchronize.py(164):     def __repr__(self):
synchronize.py(184): class RLock(SemLock):
 --- modulename: synchronize, funcname: RLock
synchronize.py(184): class RLock(SemLock):
synchronize.py(186):     def __init__(self, *, ctx):
synchronize.py(189):     def __repr__(self):
synchronize.py(210): class Condition(object):
 --- modulename: synchronize, funcname: Condition
synchronize.py(210): class Condition(object):
synchronize.py(212):     def __init__(self, lock=None, *, ctx):
synchronize.py(219):     def __getstate__(self):
synchronize.py(224):     def __setstate__(self, state):
synchronize.py(229):     def __enter__(self):
synchronize.py(232):     def __exit__(self, *args):
synchronize.py(235):     def _make_methods(self):
synchronize.py(239):     def __repr__(self):
synchronize.py(247):     def wait(self, timeout=None):
synchronize.py(270):     def notify(self, n=1):
synchronize.py(296):     def notify_all(self):
synchronize.py(299):     def wait_for(self, predicate, timeout=None):
synchronize.py(321): class Event(object):
 --- modulename: synchronize, funcname: Event
synchronize.py(321): class Event(object):
synchronize.py(323):     def __init__(self, *, ctx):
synchronize.py(327):     def is_set(self):
synchronize.py(334):     def set(self):
synchronize.py(340):     def clear(self):
synchronize.py(344):     def wait(self, timeout=None):
synchronize.py(360): class Barrier(threading.Barrier):
 --- modulename: synchronize, funcname: Barrier
synchronize.py(360): class Barrier(threading.Barrier):
synchronize.py(362):     def __init__(self, parties, action=None, timeout=None, *, ctx):
synchronize.py(371):     def __setstate__(self, state):
synchronize.py(376):     def __getstate__(self):
synchronize.py(380):     @property
synchronize.py(384):     @_state.setter
synchronize.py(388):     @property
synchronize.py(392):     @_count.setter
 --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(319): <frozen importlib._bootstrap>(320): <frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321):  --- modulename: _bootstrap, funcname: <genexpr>
<frozen importlib._bootstrap>(321): <frozen importlib._bootstrap>(327):  --- modulename: _bootstrap, funcname: _verbose_message
<frozen importlib._bootstrap>(224): <frozen importlib._bootstrap>(329): <frozen importlib._bootstrap>(682): <frozen importlib._bootstrap>(968): <frozen importlib._bootstrap>(970): <frozen importlib._bootstrap>(971): <frozen importlib._bootstrap>(972):  --- modulename: _bootstrap, funcname: __exit__
<frozen importlib._bootstrap>(152):  --- modulename: _bootstrap, funcname: release
<frozen importlib._bootstrap>(104): <frozen importlib._bootstrap>(105): <frozen importlib._bootstrap>(106): <frozen importlib._bootstrap>(108): <frozen importlib._bootstrap>(109): <frozen importlib._bootstrap>(110): <frozen importlib._bootstrap>(111): <frozen importlib._bootstrap>(112):  --- modulename: _bootstrap, funcname: cb
<frozen importlib._bootstrap>(177): <frozen importlib._bootstrap>(178): <frozen importlib._bootstrap>(182): <frozen importlib._bootstrap>(183): <frozen importlib._bootstrap>(185):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(67):         return Lock(ctx=self.get_context())
 --- modulename: context, funcname: get_context
context.py(187):         if method is None:
context.py(188):             return self
 --- modulename: synchronize, funcname: __init__
synchronize.py(162):         SemLock.__init__(self, SEMAPHORE, 1, 1, ctx=ctx)
 --- modulename: synchronize, funcname: __init__
synchronize.py(51):         if ctx is None:
synchronize.py(53):         name = ctx.get_start_method()
 --- modulename: context, funcname: get_start_method
context.py(197):         return self._name
synchronize.py(54):         unlink_now = sys.platform == 'win32' or name == 'fork'
synchronize.py(55):         for i in range(100):
synchronize.py(56):             try:
synchronize.py(57):                 sl = self._semlock = _multiprocessing.SemLock(
synchronize.py(58):                     kind, value, maxvalue, self._make_name(),
 --- modulename: synchronize, funcname: _make_name
synchronize.py(116):         return '%s-%s' % (process.current_process()._config['semprefix'],
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
synchronize.py(117):                           next(SemLock._rand))
 --- modulename: tempfile, funcname: __next__
tempfile.py(154):         c = self.characters
tempfile.py(155):         choose = self.rng.choice
 --- modulename: tempfile, funcname: rng
tempfile.py(144):         cur_pid = _os.getpid()
tempfile.py(145):         if cur_pid != getattr(self, '_rng_pid', None):
tempfile.py(146):             self._rng = _Random()
 --- modulename: random, funcname: __init__
random.py(94):         self.seed(x)
 --- modulename: random, funcname: seed
random.py(112):         if version == 1 and isinstance(a, (str, bytes)):
random.py(120):         if version == 2 and isinstance(a, (str, bytes, bytearray)):
random.py(126):         super().seed(a)
random.py(127):         self.gauss_next = None
random.py(95):         self.gauss_next = None
tempfile.py(147):             self._rng_pid = cur_pid
tempfile.py(148):         return self._rng
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: tempfile, funcname: <listcomp>
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
tempfile.py(157):         return ''.join(letters)
synchronize.py(59):                     unlink_now)
synchronize.py(63):                 break
synchronize.py(67):         util.debug('created semlock with handle %s' % sl.handle)
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
synchronize.py(68):         self._make_methods()
 --- modulename: synchronize, funcname: _make_methods
synchronize.py(91):         self.acquire = self._semlock.acquire
synchronize.py(92):         self.release = self._semlock.release
synchronize.py(70):         if sys.platform != 'win32':
synchronize.py(75):         if self._semlock.name is not None:
queues.py(43):         self._opid = os.getpid()
queues.py(44):         if sys.platform == 'win32':
queues.py(45):             self._wlock = None
queues.py(48):         self._sem = ctx.BoundedSemaphore(maxsize)
 --- modulename: context, funcname: BoundedSemaphore
context.py(86):         from .synchronize import BoundedSemaphore
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(87):         return BoundedSemaphore(value, ctx=self.get_context())
 --- modulename: context, funcname: get_context
context.py(187):         if method is None:
context.py(188):             return self
 --- modulename: synchronize, funcname: __init__
synchronize.py(145):         SemLock.__init__(self, SEMAPHORE, value, value, ctx=ctx)
 --- modulename: synchronize, funcname: __init__
synchronize.py(51):         if ctx is None:
synchronize.py(53):         name = ctx.get_start_method()
 --- modulename: context, funcname: get_start_method
context.py(197):         return self._name
synchronize.py(54):         unlink_now = sys.platform == 'win32' or name == 'fork'
synchronize.py(55):         for i in range(100):
synchronize.py(56):             try:
synchronize.py(57):                 sl = self._semlock = _multiprocessing.SemLock(
synchronize.py(58):                     kind, value, maxvalue, self._make_name(),
 --- modulename: synchronize, funcname: _make_name
synchronize.py(116):         return '%s-%s' % (process.current_process()._config['semprefix'],
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
synchronize.py(117):                           next(SemLock._rand))
 --- modulename: tempfile, funcname: __next__
tempfile.py(154):         c = self.characters
tempfile.py(155):         choose = self.rng.choice
 --- modulename: tempfile, funcname: rng
tempfile.py(144):         cur_pid = _os.getpid()
tempfile.py(145):         if cur_pid != getattr(self, '_rng_pid', None):
tempfile.py(148):         return self._rng
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: tempfile, funcname: <listcomp>
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
tempfile.py(157):         return ''.join(letters)
synchronize.py(59):                     unlink_now)
synchronize.py(63):                 break
synchronize.py(67):         util.debug('created semlock with handle %s' % sl.handle)
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
synchronize.py(68):         self._make_methods()
 --- modulename: synchronize, funcname: _make_methods
synchronize.py(91):         self.acquire = self._semlock.acquire
synchronize.py(92):         self.release = self._semlock.release
synchronize.py(70):         if sys.platform != 'win32':
synchronize.py(75):         if self._semlock.name is not None:
queues.py(50):         self._ignore_epipe = False
queues.py(52):         self._after_fork()
 --- modulename: queues, funcname: _after_fork
queues.py(68):         debug('Queue._after_fork()')
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
queues.py(69):         self._notempty = threading.Condition(threading.Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
queues.py(70):         self._buffer = collections.deque()
queues.py(71):         self._thread = None
queues.py(72):         self._jointhread = None
queues.py(73):         self._joincancelled = False
queues.py(74):         self._closed = False
queues.py(75):         self._close = None
queues.py(76):         self._send_bytes = self._writer.send_bytes
queues.py(77):         self._recv_bytes = self._reader.recv_bytes
queues.py(78):         self._poll = self._reader.poll
queues.py(54):         if sys.platform != 'win32':
process.py(560):         self._call_queue._ignore_epipe = True
process.py(561):         self._result_queue = mp_context.SimpleQueue()
 --- modulename: context, funcname: SimpleQueue
context.py(111):         from .queues import SimpleQueue
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(112):         return SimpleQueue(ctx=self.get_context())
 --- modulename: context, funcname: get_context
context.py(187):         if method is None:
context.py(188):             return self
 --- modulename: queues, funcname: __init__
queues.py(331):         self._reader, self._writer = connection.Pipe(duplex=False)
 --- modulename: connection, funcname: Pipe
connection.py(529):         address = arbitrary_address('AF_PIPE')
 --- modulename: connection, funcname: arbitrary_address
connection.py(73):     if family == 'AF_INET':
connection.py(75):     elif family == 'AF_UNIX':
connection.py(77):     elif family == 'AF_PIPE':
connection.py(78):         return tempfile.mktemp(prefix=r'\\.\pipe\pyc-%d-%d-' %
connection.py(79):                                (os.getpid(), next(_mmap_counter)), dir="")
 --- modulename: tempfile, funcname: mktemp
tempfile.py(400):     if dir is None:
tempfile.py(403):     names = _get_candidate_names()
 --- modulename: tempfile, funcname: _get_candidate_names
tempfile.py(237):     if _name_sequence is None:
tempfile.py(244):     return _name_sequence
tempfile.py(404):     for seq in range(TMP_MAX):
tempfile.py(405):         name = next(names)
 --- modulename: tempfile, funcname: __next__
tempfile.py(154):         c = self.characters
tempfile.py(155):         choose = self.rng.choice
 --- modulename: tempfile, funcname: rng
tempfile.py(144):         cur_pid = _os.getpid()
tempfile.py(145):         if cur_pid != getattr(self, '_rng_pid', None):
tempfile.py(148):         return self._rng
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: tempfile, funcname: <listcomp>
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
tempfile.py(157):         return ''.join(letters)
tempfile.py(406):         file = _os.path.join(dir, prefix + name + suffix)
 --- modulename: ntpath, funcname: join
ntpath.py(76):     path = os.fspath(path)
ntpath.py(77):     if isinstance(path, bytes):
ntpath.py(82):         sep = '\\'
ntpath.py(83):         seps = '\\/'
ntpath.py(84):         colon = ':'
ntpath.py(85):     try:
ntpath.py(86):         if not paths:
ntpath.py(88):         result_drive, result_path = splitdrive(path)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(170):     return p[:0], p
ntpath.py(89):         for p in map(os.fspath, paths):
ntpath.py(90):             p_drive, p_path = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(157):             index = normp.find(sep, 2)
ntpath.py(158):             if index == -1:
ntpath.py(160):             index2 = normp.find(sep, index + 1)
ntpath.py(163):             if index2 == index + 1:
ntpath.py(165):             if index2 == -1:
ntpath.py(167):             return p[:index2], p[index2:]
ntpath.py(91):             if p_path and p_path[0] in seps:
ntpath.py(93):                 if p_drive or not result_drive:
ntpath.py(94):                     result_drive = p_drive
ntpath.py(95):                 result_path = p_path
ntpath.py(96):                 continue
ntpath.py(89):         for p in map(os.fspath, paths):
ntpath.py(110):         if (result_path and result_path[0] not in seps and
ntpath.py(113):         return result_drive + result_path
tempfile.py(407):         if not _exists(file):
 --- modulename: tempfile, funcname: _exists
tempfile.py(85):     try:
tempfile.py(86):         _stat(fn)
tempfile.py(87):     except OSError:
tempfile.py(88):         return False
tempfile.py(408):             return file
connection.py(530):         if duplex:
connection.py(535):             openmode = _winapi.PIPE_ACCESS_INBOUND
connection.py(536):             access = _winapi.GENERIC_WRITE
connection.py(537):             obsize, ibsize = 0, BUFSIZE
connection.py(539):         h1 = _winapi.CreateNamedPipe(
connection.py(540):             address, openmode | _winapi.FILE_FLAG_OVERLAPPED |
connection.py(541):             _winapi.FILE_FLAG_FIRST_PIPE_INSTANCE,
connection.py(542):             _winapi.PIPE_TYPE_MESSAGE | _winapi.PIPE_READMODE_MESSAGE |
connection.py(543):             _winapi.PIPE_WAIT,
connection.py(544):             1, obsize, ibsize, _winapi.NMPWAIT_WAIT_FOREVER,
connection.py(546):             _winapi.NULL
connection.py(548):         h2 = _winapi.CreateFile(
connection.py(549):             address, access, 0, _winapi.NULL, _winapi.OPEN_EXISTING,
connection.py(550):             _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL
connection.py(552):         _winapi.SetNamedPipeHandleState(
connection.py(553):             h2, _winapi.PIPE_READMODE_MESSAGE, None, None
connection.py(556):         overlapped = _winapi.ConnectNamedPipe(h1, overlapped=True)
connection.py(557):         _, err = overlapped.GetOverlappedResult(True)
connection.py(558):         assert err == 0
connection.py(560):         c1 = PipeConnection(h1, writable=duplex)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(561):         c2 = PipeConnection(h2, readable=duplex)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(563):         return c1, c2
queues.py(332):         self._rlock = ctx.Lock()
 --- modulename: context, funcname: Lock
context.py(66):         from .synchronize import Lock
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(67):         return Lock(ctx=self.get_context())
 --- modulename: context, funcname: get_context
context.py(187):         if method is None:
context.py(188):             return self
 --- modulename: synchronize, funcname: __init__
synchronize.py(162):         SemLock.__init__(self, SEMAPHORE, 1, 1, ctx=ctx)
 --- modulename: synchronize, funcname: __init__
synchronize.py(51):         if ctx is None:
synchronize.py(53):         name = ctx.get_start_method()
 --- modulename: context, funcname: get_start_method
context.py(197):         return self._name
synchronize.py(54):         unlink_now = sys.platform == 'win32' or name == 'fork'
synchronize.py(55):         for i in range(100):
synchronize.py(56):             try:
synchronize.py(57):                 sl = self._semlock = _multiprocessing.SemLock(
synchronize.py(58):                     kind, value, maxvalue, self._make_name(),
 --- modulename: synchronize, funcname: _make_name
synchronize.py(116):         return '%s-%s' % (process.current_process()._config['semprefix'],
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
synchronize.py(117):                           next(SemLock._rand))
 --- modulename: tempfile, funcname: __next__
tempfile.py(154):         c = self.characters
tempfile.py(155):         choose = self.rng.choice
 --- modulename: tempfile, funcname: rng
tempfile.py(144):         cur_pid = _os.getpid()
tempfile.py(145):         if cur_pid != getattr(self, '_rng_pid', None):
tempfile.py(148):         return self._rng
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: tempfile, funcname: <listcomp>
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
tempfile.py(157):         return ''.join(letters)
synchronize.py(59):                     unlink_now)
synchronize.py(63):                 break
synchronize.py(67):         util.debug('created semlock with handle %s' % sl.handle)
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
synchronize.py(68):         self._make_methods()
 --- modulename: synchronize, funcname: _make_methods
synchronize.py(91):         self.acquire = self._semlock.acquire
synchronize.py(92):         self.release = self._semlock.release
synchronize.py(70):         if sys.platform != 'win32':
synchronize.py(75):         if self._semlock.name is not None:
queues.py(333):         self._poll = self._reader.poll
queues.py(334):         if sys.platform == 'win32':
queues.py(335):             self._wlock = None
process.py(562):         self._work_ids = queue.Queue()
 --- modulename: queue, funcname: __init__
queue.py(34):         self.maxsize = maxsize
queue.py(35):         self._init(maxsize)
 --- modulename: queue, funcname: _init
queue.py(206):         self.queue = deque()
queue.py(41):         self.mutex = threading.Lock()
queue.py(45):         self.not_empty = threading.Condition(self.mutex)
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
queue.py(49):         self.not_full = threading.Condition(self.mutex)
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
queue.py(53):         self.all_tasks_done = threading.Condition(self.mutex)
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
queue.py(54):         self.unfinished_tasks = 0
process.py(570):         self._queue_management_thread_wakeup = _ThreadWakeup()
 --- modulename: process, funcname: __init__
process.py(83):         self._reader, self._writer = mp.Pipe(duplex=False)
 --- modulename: context, funcname: Pipe
context.py(61):         from .connection import Pipe
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(62):         return Pipe(duplex)
 --- modulename: connection, funcname: Pipe
connection.py(529):         address = arbitrary_address('AF_PIPE')
 --- modulename: connection, funcname: arbitrary_address
connection.py(73):     if family == 'AF_INET':
connection.py(75):     elif family == 'AF_UNIX':
connection.py(77):     elif family == 'AF_PIPE':
connection.py(78):         return tempfile.mktemp(prefix=r'\\.\pipe\pyc-%d-%d-' %
connection.py(79):                                (os.getpid(), next(_mmap_counter)), dir="")
 --- modulename: tempfile, funcname: mktemp
tempfile.py(400):     if dir is None:
tempfile.py(403):     names = _get_candidate_names()
 --- modulename: tempfile, funcname: _get_candidate_names
tempfile.py(237):     if _name_sequence is None:
tempfile.py(244):     return _name_sequence
tempfile.py(404):     for seq in range(TMP_MAX):
tempfile.py(405):         name = next(names)
 --- modulename: tempfile, funcname: __next__
tempfile.py(154):         c = self.characters
tempfile.py(155):         choose = self.rng.choice
 --- modulename: tempfile, funcname: rng
tempfile.py(144):         cur_pid = _os.getpid()
tempfile.py(145):         if cur_pid != getattr(self, '_rng_pid', None):
tempfile.py(148):         return self._rng
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: tempfile, funcname: <listcomp>
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
 --- modulename: random, funcname: choice
random.py(258):         try:
random.py(259):             i = self._randbelow(len(seq))
 --- modulename: random, funcname: _randbelow
random.py(228):         random = self.random
random.py(229):         getrandbits = self.getrandbits
random.py(232):         if type(random) is BuiltinMethod or type(getrandbits) is Method:
random.py(233):             k = n.bit_length()  # don't use (n-1) here because n can be 1
random.py(234):             r = getrandbits(k)          # 0 <= r < 2**k
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(236):                 r = getrandbits(k)
random.py(235):             while r >= n:
random.py(237):             return r
random.py(262):         return seq[i]
tempfile.py(156):         letters = [choose(c) for dummy in range(8)]
tempfile.py(157):         return ''.join(letters)
tempfile.py(406):         file = _os.path.join(dir, prefix + name + suffix)
 --- modulename: ntpath, funcname: join
ntpath.py(76):     path = os.fspath(path)
ntpath.py(77):     if isinstance(path, bytes):
ntpath.py(82):         sep = '\\'
ntpath.py(83):         seps = '\\/'
ntpath.py(84):         colon = ':'
ntpath.py(85):     try:
ntpath.py(86):         if not paths:
ntpath.py(88):         result_drive, result_path = splitdrive(path)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(170):     return p[:0], p
ntpath.py(89):         for p in map(os.fspath, paths):
ntpath.py(90):             p_drive, p_path = splitdrive(p)
 --- modulename: ntpath, funcname: splitdrive
ntpath.py(141):     p = os.fspath(p)
ntpath.py(142):     if len(p) >= 2:
ntpath.py(143):         if isinstance(p, bytes):
ntpath.py(148):             sep = '\\'
ntpath.py(149):             altsep = '/'
ntpath.py(150):             colon = ':'
ntpath.py(151):         normp = p.replace(altsep, sep)
ntpath.py(152):         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
ntpath.py(157):             index = normp.find(sep, 2)
ntpath.py(158):             if index == -1:
ntpath.py(160):             index2 = normp.find(sep, index + 1)
ntpath.py(163):             if index2 == index + 1:
ntpath.py(165):             if index2 == -1:
ntpath.py(167):             return p[:index2], p[index2:]
ntpath.py(91):             if p_path and p_path[0] in seps:
ntpath.py(93):                 if p_drive or not result_drive:
ntpath.py(94):                     result_drive = p_drive
ntpath.py(95):                 result_path = p_path
ntpath.py(96):                 continue
ntpath.py(89):         for p in map(os.fspath, paths):
ntpath.py(110):         if (result_path and result_path[0] not in seps and
ntpath.py(113):         return result_drive + result_path
tempfile.py(407):         if not _exists(file):
 --- modulename: tempfile, funcname: _exists
tempfile.py(85):     try:
tempfile.py(86):         _stat(fn)
tempfile.py(87):     except OSError:
tempfile.py(88):         return False
tempfile.py(408):             return file
connection.py(530):         if duplex:
connection.py(535):             openmode = _winapi.PIPE_ACCESS_INBOUND
connection.py(536):             access = _winapi.GENERIC_WRITE
connection.py(537):             obsize, ibsize = 0, BUFSIZE
connection.py(539):         h1 = _winapi.CreateNamedPipe(
connection.py(540):             address, openmode | _winapi.FILE_FLAG_OVERLAPPED |
connection.py(541):             _winapi.FILE_FLAG_FIRST_PIPE_INSTANCE,
connection.py(542):             _winapi.PIPE_TYPE_MESSAGE | _winapi.PIPE_READMODE_MESSAGE |
connection.py(543):             _winapi.PIPE_WAIT,
connection.py(544):             1, obsize, ibsize, _winapi.NMPWAIT_WAIT_FOREVER,
connection.py(546):             _winapi.NULL
connection.py(548):         h2 = _winapi.CreateFile(
connection.py(549):             address, access, 0, _winapi.NULL, _winapi.OPEN_EXISTING,
connection.py(550):             _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL
connection.py(552):         _winapi.SetNamedPipeHandleState(
connection.py(553):             h2, _winapi.PIPE_READMODE_MESSAGE, None, None
connection.py(556):         overlapped = _winapi.ConnectNamedPipe(h1, overlapped=True)
connection.py(557):         _, err = overlapped.GetOverlappedResult(True)
connection.py(558):         assert err == 0
connection.py(560):         c1 = PipeConnection(h1, writable=duplex)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(561):         c2 = PipeConnection(h2, readable=duplex)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(563):         return c1, c2
 --- modulename: _base, funcname: __enter__
_base.py(620):         return self
PhoneBot.py(557):             try:
PhoneBot.py(558):                 multiprocesses = executor.map(mymodules.run_smartphone, list_arguments_smartphones)
 --- modulename: process, funcname: map
process.py(666):         if chunksize < 1:
process.py(669):         results = super().map(partial(_process_chunk, fn),
process.py(670):                               _get_chunks(*iterables, chunksize=chunksize),
process.py(671):                               timeout=timeout)
 --- modulename: _base, funcname: map
_base.py(584):         if timeout is not None:
_base.py(587):         fs = [self.submit(fn, *args) for args in zip(*iterables)]
 --- modulename: _base, funcname: <listcomp>
_base.py(587):         fs = [self.submit(fn, *args) for args in zip(*iterables)]
 --- modulename: process, funcname: _get_chunks
process.py(182):     it = zip(*iterables)
process.py(183):     while True:
process.py(184):         chunk = tuple(itertools.islice(it, chunksize))
process.py(185):         if not chunk:
process.py(187):         yield chunk
 --- modulename: process, funcname: submit
process.py(611):         if len(args) >= 2:
process.py(612):             self, fn, *args = args
process.py(623):         with self._shutdown_lock:
process.py(624):             if self._broken:
process.py(626):             if self._shutdown_thread:
process.py(628):             if _global_shutdown:
process.py(632):             f = _base.Future()
 --- modulename: _base, funcname: __init__
_base.py(314):         self._condition = threading.Condition()
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(218):             lock = RLock()
 --- modulename: threading, funcname: RLock
threading.py(84):     if _CRLock is None:
threading.py(86):     return _CRLock(*args, **kwargs)
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(238):         self._waiters = _deque()
_base.py(315):         self._state = PENDING
_base.py(316):         self._result = None
_base.py(317):         self._exception = None
_base.py(318):         self._waiters = []
_base.py(319):         self._done_callbacks = []
process.py(633):             w = _WorkItem(f, fn, args, kwargs)
 --- modulename: process, funcname: __init__
process.py(142):         self.future = future
process.py(143):         self.fn = fn
process.py(144):         self.args = args
process.py(145):         self.kwargs = kwargs
process.py(635):             self._pending_work_items[self._queue_count] = w
process.py(636):             self._work_ids.put(self._queue_count)
 --- modulename: queue, funcname: put
queue.py(132):         with self.not_full:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
queue.py(133):             if self.maxsize > 0:
queue.py(149):             self._put(item)
 --- modulename: queue, funcname: _put
queue.py(213):         self.queue.append(item)
queue.py(150):             self.unfinished_tasks += 1
queue.py(151):             self.not_empty.notify()
 --- modulename: threading, funcname: notify
threading.py(345):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(347):         all_waiters = self._waiters
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
threading.py(349):         if not waiters_to_notify:
threading.py(350):             return
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
process.py(637):             self._queue_count += 1
process.py(639):             self._queue_management_thread_wakeup.wakeup()
 --- modulename: process, funcname: wakeup
process.py(90):         self._writer.send_bytes(b"")
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
process.py(641):             self._start_queue_management_thread()
 --- modulename: process, funcname: _start_queue_management_thread
process.py(573):         if self._queue_management_thread is None:
process.py(578):                            thread_wakeup=self._queue_management_thread_wakeup):
process.py(583):             self._adjust_process_count()
 --- modulename: process, funcname: _adjust_process_count
process.py(600):         for _ in range(len(self._processes), self._max_workers):
process.py(601):             p = self._mp_context.Process(
process.py(602):                 target=_process_worker,
process.py(603):                 args=(self._call_queue,
process.py(604):                       self._result_queue,
process.py(605):                       self._initializer,
process.py(606):                       self._initargs))
 --- modulename: process, funcname: __init__
process.py(74):         assert group is None, 'group argument must be None for now'
process.py(75):         count = next(_process_counter)
process.py(76):         self._identity = _current_process._identity + (count,)
process.py(77):         self._config = _current_process._config.copy()
process.py(78):         self._parent_pid = os.getpid()
process.py(79):         self._popen = None
process.py(80):         self._closed = False
process.py(81):         self._target = target
process.py(82):         self._args = tuple(args)
process.py(83):         self._kwargs = dict(kwargs)
process.py(84):         self._name = name or type(self).__name__ + '-' + \
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
process.py(86):         if daemon is not None:
process.py(88):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
process.py(607):             p.start()
 --- modulename: process, funcname: start
process.py(105):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(106):         assert self._popen is None, 'cannot start a process twice'
process.py(107):         assert self._parent_pid == os.getpid(), \
process.py(109):         assert not _current_process._config.get('daemon'), \
process.py(111):         _cleanup()
 --- modulename: process, funcname: _cleanup
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(112):         self._popen = self._Popen(self)
 --- modulename: context, funcname: _Popen
context.py(321):             from .popen_spawn_win32 import Popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(322):             return Popen(process_obj)
 --- modulename: popen_spawn_win32, funcname: __init__
popen_spawn_win32.py(46):         prep_data = spawn.get_preparation_data(process_obj._name)
 --- modulename: spawn, funcname: get_preparation_data
spawn.py(143):     _check_not_importing_main()
 --- modulename: spawn, funcname: _check_not_importing_main
spawn.py(122):     if getattr(process.current_process(), '_inheriting', False):
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
spawn.py(144):     d = dict(
spawn.py(145):         log_to_stderr=util._log_to_stderr,
spawn.py(146):         authkey=process.current_process().authkey,
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: authkey
process.py(206):         return self._config['authkey']
spawn.py(149):     if util._logger is not None:
spawn.py(152):     sys_path=sys.path.copy()
spawn.py(153):     try:
spawn.py(154):         i = sys_path.index('')
spawn.py(158):         sys_path[i] = process.ORIGINAL_DIR
spawn.py(160):     d.update(
spawn.py(161):         name=name,
spawn.py(162):         sys_path=sys_path,
spawn.py(163):         sys_argv=sys.argv,
spawn.py(164):         orig_dir=process.ORIGINAL_DIR,
spawn.py(165):         dir=os.getcwd(),
spawn.py(166):         start_method=get_start_method(),
 --- modulename: context, funcname: get_start_method
context.py(249):         if self._actual_context is None:
context.py(253):         return self._actual_context._name
spawn.py(171):     main_module = sys.modules['__main__']
spawn.py(172):     main_mod_name = getattr(main_module.__spec__, "name", None)
spawn.py(173):     if main_mod_name is not None:
spawn.py(174):         d['init_main_from_name'] = main_mod_name
spawn.py(183):     return d
popen_spawn_win32.py(50):         rhandle, whandle = _winapi.CreatePipe(None, 0)
popen_spawn_win32.py(51):         wfd = msvcrt.open_osfhandle(whandle, 0)
popen_spawn_win32.py(52):         cmd = spawn.get_command_line(parent_pid=os.getpid(),
popen_spawn_win32.py(53):                                      pipe_handle=rhandle)
 --- modulename: spawn, funcname: get_command_line
spawn.py(82):     if getattr(sys, 'frozen', False):
spawn.py(86):         prog = 'from multiprocessing.spawn import spawn_main; spawn_main(%s)'
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
spawn.py(88):         opts = util._args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _args_from_interpreter_flags
subprocess.py(260):         'debug': 'd',
subprocess.py(263):         'dont_write_bytecode': 'B',
subprocess.py(264):         'no_site': 'S',
subprocess.py(265):         'verbose': 'v',
subprocess.py(266):         'bytes_warning': 'b',
subprocess.py(267):         'quiet': 'q',
subprocess.py(270):     args = _optim_args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _optim_args_from_interpreter_flags
subprocess.py(249):     args = []
subprocess.py(250):     value = sys.flags.optimize
subprocess.py(251):     if value > 0:
subprocess.py(253):     return args
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(276):     if sys.flags.isolated:
subprocess.py(279):         if sys.flags.ignore_environment:
subprocess.py(281):         if sys.flags.no_user_site:
subprocess.py(285):     warnopts = sys.warnoptions[:]
subprocess.py(286):     bytes_warning = sys.flags.bytes_warning
subprocess.py(287):     xoptions = getattr(sys, '_xoptions', {})
subprocess.py(288):     dev_mode = ('dev' in xoptions)
subprocess.py(290):     if bytes_warning > 1:
subprocess.py(292):     elif bytes_warning:
subprocess.py(294):     if dev_mode:
subprocess.py(296):     for opt in warnopts:
subprocess.py(300):     if dev_mode:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(312):     return args
spawn.py(89):         return [_python_exe] + opts + ['-c', prog, '--multiprocessing-fork']
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
popen_spawn_win32.py(56):         python_exe = spawn.get_executable()
 --- modulename: spawn, funcname: get_executable
spawn.py(46):     return _python_exe
popen_spawn_win32.py(60):         if WINENV and _path_eq(python_exe, sys.executable):
popen_spawn_win32.py(65):             env = None
popen_spawn_win32.py(67):         with open(wfd, 'wb', closefd=True) as to_child:
popen_spawn_win32.py(69):             try:
popen_spawn_win32.py(70):                 hp, ht, pid, tid = _winapi.CreateProcess(
popen_spawn_win32.py(71):                     python_exe, cmd,
popen_spawn_win32.py(72):                     env, None, False, 0, None, None, None)
popen_spawn_win32.py(73):                 _winapi.CloseHandle(ht)
popen_spawn_win32.py(79):             self.pid = pid
popen_spawn_win32.py(80):             self.returncode = None
popen_spawn_win32.py(81):             self._handle = hp
popen_spawn_win32.py(82):             self.sentinel = int(hp)
popen_spawn_win32.py(83):             self.finalizer = util.Finalize(self, _winapi.CloseHandle, (self.sentinel,))
 --- modulename: util, funcname: __init__
util.py(152):         if (exitpriority is not None) and not isinstance(exitpriority,int):
util.py(157):         if obj is not None:
util.py(158):             self._weakref = weakref.ref(obj, self)
util.py(162):         self._callback = callback
util.py(163):         self._args = args
util.py(164):         self._kwargs = kwargs or {}
util.py(165):         self._key = (exitpriority, next(_finalizer_counter))
util.py(166):         self._pid = os.getpid()
util.py(168):         _finalizer_registry[self._key] = self
popen_spawn_win32.py(86):             set_spawning_popen(self)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
popen_spawn_win32.py(87):             try:
popen_spawn_win32.py(88):                 reduction.dump(prep_data, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
popen_spawn_win32.py(89):                 reduction.dump(process_obj, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
 --- modulename: queues, funcname: __getstate__
queues.py(58):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(59):         return (self._ignore_epipe, self._maxsize, self._reader, self._writer,
queues.py(60):                 self._rlock, self._wlock, self._sem, self._opid)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: queues, funcname: __getstate__
queues.py(343):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(344):         return (self._reader, self._writer, self._rlock, self._wlock)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
popen_spawn_win32.py(91):                 set_spawning_popen(None)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
process.py(113):         self._sentinel = self._popen.sentinel
process.py(116):         del self._target, self._args, self._kwargs
process.py(117):         _children.add(self)
process.py(608):             self._processes[p.pid] = p
 --- modulename: process, funcname: ident
process.py(230):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(231):         if self is _current_process:
process.py(234):             return self._popen and self._popen.pid
process.py(600):         for _ in range(len(self._processes), self._max_workers):
process.py(601):             p = self._mp_context.Process(
process.py(602):                 target=_process_worker,
process.py(603):                 args=(self._call_queue,
process.py(604):                       self._result_queue,
process.py(605):                       self._initializer,
process.py(606):                       self._initargs))
 --- modulename: process, funcname: __init__
process.py(74):         assert group is None, 'group argument must be None for now'
process.py(75):         count = next(_process_counter)
process.py(76):         self._identity = _current_process._identity + (count,)
process.py(77):         self._config = _current_process._config.copy()
process.py(78):         self._parent_pid = os.getpid()
process.py(79):         self._popen = None
process.py(80):         self._closed = False
process.py(81):         self._target = target
process.py(82):         self._args = tuple(args)
process.py(83):         self._kwargs = dict(kwargs)
process.py(84):         self._name = name or type(self).__name__ + '-' + \
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
process.py(86):         if daemon is not None:
process.py(88):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
process.py(607):             p.start()
 --- modulename: process, funcname: start
process.py(105):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(106):         assert self._popen is None, 'cannot start a process twice'
process.py(107):         assert self._parent_pid == os.getpid(), \
process.py(109):         assert not _current_process._config.get('daemon'), \
process.py(111):         _cleanup()
 --- modulename: process, funcname: _cleanup
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(112):         self._popen = self._Popen(self)
 --- modulename: context, funcname: _Popen
context.py(321):             from .popen_spawn_win32 import Popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(322):             return Popen(process_obj)
 --- modulename: popen_spawn_win32, funcname: __init__
popen_spawn_win32.py(46):         prep_data = spawn.get_preparation_data(process_obj._name)
 --- modulename: spawn, funcname: get_preparation_data
spawn.py(143):     _check_not_importing_main()
 --- modulename: spawn, funcname: _check_not_importing_main
spawn.py(122):     if getattr(process.current_process(), '_inheriting', False):
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
spawn.py(144):     d = dict(
spawn.py(145):         log_to_stderr=util._log_to_stderr,
spawn.py(146):         authkey=process.current_process().authkey,
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: authkey
process.py(206):         return self._config['authkey']
spawn.py(149):     if util._logger is not None:
spawn.py(152):     sys_path=sys.path.copy()
spawn.py(153):     try:
spawn.py(154):         i = sys_path.index('')
spawn.py(158):         sys_path[i] = process.ORIGINAL_DIR
spawn.py(160):     d.update(
spawn.py(161):         name=name,
spawn.py(162):         sys_path=sys_path,
spawn.py(163):         sys_argv=sys.argv,
spawn.py(164):         orig_dir=process.ORIGINAL_DIR,
spawn.py(165):         dir=os.getcwd(),
spawn.py(166):         start_method=get_start_method(),
 --- modulename: context, funcname: get_start_method
context.py(249):         if self._actual_context is None:
context.py(253):         return self._actual_context._name
spawn.py(171):     main_module = sys.modules['__main__']
spawn.py(172):     main_mod_name = getattr(main_module.__spec__, "name", None)
spawn.py(173):     if main_mod_name is not None:
spawn.py(174):         d['init_main_from_name'] = main_mod_name
spawn.py(183):     return d
popen_spawn_win32.py(50):         rhandle, whandle = _winapi.CreatePipe(None, 0)
popen_spawn_win32.py(51):         wfd = msvcrt.open_osfhandle(whandle, 0)
popen_spawn_win32.py(52):         cmd = spawn.get_command_line(parent_pid=os.getpid(),
popen_spawn_win32.py(53):                                      pipe_handle=rhandle)
 --- modulename: spawn, funcname: get_command_line
spawn.py(82):     if getattr(sys, 'frozen', False):
spawn.py(86):         prog = 'from multiprocessing.spawn import spawn_main; spawn_main(%s)'
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
spawn.py(88):         opts = util._args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _args_from_interpreter_flags
subprocess.py(260):         'debug': 'd',
subprocess.py(263):         'dont_write_bytecode': 'B',
subprocess.py(264):         'no_site': 'S',
subprocess.py(265):         'verbose': 'v',
subprocess.py(266):         'bytes_warning': 'b',
subprocess.py(267):         'quiet': 'q',
subprocess.py(270):     args = _optim_args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _optim_args_from_interpreter_flags
subprocess.py(249):     args = []
subprocess.py(250):     value = sys.flags.optimize
subprocess.py(251):     if value > 0:
subprocess.py(253):     return args
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(276):     if sys.flags.isolated:
subprocess.py(279):         if sys.flags.ignore_environment:
subprocess.py(281):         if sys.flags.no_user_site:
subprocess.py(285):     warnopts = sys.warnoptions[:]
subprocess.py(286):     bytes_warning = sys.flags.bytes_warning
subprocess.py(287):     xoptions = getattr(sys, '_xoptions', {})
subprocess.py(288):     dev_mode = ('dev' in xoptions)
subprocess.py(290):     if bytes_warning > 1:
subprocess.py(292):     elif bytes_warning:
subprocess.py(294):     if dev_mode:
subprocess.py(296):     for opt in warnopts:
subprocess.py(300):     if dev_mode:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(312):     return args
spawn.py(89):         return [_python_exe] + opts + ['-c', prog, '--multiprocessing-fork']
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
popen_spawn_win32.py(56):         python_exe = spawn.get_executable()
 --- modulename: spawn, funcname: get_executable
spawn.py(46):     return _python_exe
popen_spawn_win32.py(60):         if WINENV and _path_eq(python_exe, sys.executable):
popen_spawn_win32.py(65):             env = None
popen_spawn_win32.py(67):         with open(wfd, 'wb', closefd=True) as to_child:
popen_spawn_win32.py(69):             try:
popen_spawn_win32.py(70):                 hp, ht, pid, tid = _winapi.CreateProcess(
popen_spawn_win32.py(71):                     python_exe, cmd,
popen_spawn_win32.py(72):                     env, None, False, 0, None, None, None)
popen_spawn_win32.py(73):                 _winapi.CloseHandle(ht)
popen_spawn_win32.py(79):             self.pid = pid
popen_spawn_win32.py(80):             self.returncode = None
popen_spawn_win32.py(81):             self._handle = hp
popen_spawn_win32.py(82):             self.sentinel = int(hp)
popen_spawn_win32.py(83):             self.finalizer = util.Finalize(self, _winapi.CloseHandle, (self.sentinel,))
 --- modulename: util, funcname: __init__
util.py(152):         if (exitpriority is not None) and not isinstance(exitpriority,int):
util.py(157):         if obj is not None:
util.py(158):             self._weakref = weakref.ref(obj, self)
util.py(162):         self._callback = callback
util.py(163):         self._args = args
util.py(164):         self._kwargs = kwargs or {}
util.py(165):         self._key = (exitpriority, next(_finalizer_counter))
util.py(166):         self._pid = os.getpid()
util.py(168):         _finalizer_registry[self._key] = self
popen_spawn_win32.py(86):             set_spawning_popen(self)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
popen_spawn_win32.py(87):             try:
popen_spawn_win32.py(88):                 reduction.dump(prep_data, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
popen_spawn_win32.py(89):                 reduction.dump(process_obj, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
 --- modulename: queues, funcname: __getstate__
queues.py(58):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(59):         return (self._ignore_epipe, self._maxsize, self._reader, self._writer,
queues.py(60):                 self._rlock, self._wlock, self._sem, self._opid)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: queues, funcname: __getstate__
queues.py(343):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(344):         return (self._reader, self._writer, self._rlock, self._wlock)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
popen_spawn_win32.py(91):                 set_spawning_popen(None)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
process.py(113):         self._sentinel = self._popen.sentinel
process.py(116):         del self._target, self._args, self._kwargs
process.py(117):         _children.add(self)
process.py(608):             self._processes[p.pid] = p
 --- modulename: process, funcname: ident
process.py(230):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(231):         if self is _current_process:
process.py(234):             return self._popen and self._popen.pid
process.py(600):         for _ in range(len(self._processes), self._max_workers):
process.py(601):             p = self._mp_context.Process(
process.py(602):                 target=_process_worker,
process.py(603):                 args=(self._call_queue,
process.py(604):                       self._result_queue,
process.py(605):                       self._initializer,
process.py(606):                       self._initargs))
 --- modulename: process, funcname: __init__
process.py(74):         assert group is None, 'group argument must be None for now'
process.py(75):         count = next(_process_counter)
process.py(76):         self._identity = _current_process._identity + (count,)
process.py(77):         self._config = _current_process._config.copy()
process.py(78):         self._parent_pid = os.getpid()
process.py(79):         self._popen = None
process.py(80):         self._closed = False
process.py(81):         self._target = target
process.py(82):         self._args = tuple(args)
process.py(83):         self._kwargs = dict(kwargs)
process.py(84):         self._name = name or type(self).__name__ + '-' + \
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
process.py(86):         if daemon is not None:
process.py(88):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
process.py(607):             p.start()
 --- modulename: process, funcname: start
process.py(105):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(106):         assert self._popen is None, 'cannot start a process twice'
process.py(107):         assert self._parent_pid == os.getpid(), \
process.py(109):         assert not _current_process._config.get('daemon'), \
process.py(111):         _cleanup()
 --- modulename: process, funcname: _cleanup
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(112):         self._popen = self._Popen(self)
 --- modulename: context, funcname: _Popen
context.py(321):             from .popen_spawn_win32 import Popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(322):             return Popen(process_obj)
 --- modulename: popen_spawn_win32, funcname: __init__
popen_spawn_win32.py(46):         prep_data = spawn.get_preparation_data(process_obj._name)
 --- modulename: spawn, funcname: get_preparation_data
spawn.py(143):     _check_not_importing_main()
 --- modulename: spawn, funcname: _check_not_importing_main
spawn.py(122):     if getattr(process.current_process(), '_inheriting', False):
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
spawn.py(144):     d = dict(
spawn.py(145):         log_to_stderr=util._log_to_stderr,
spawn.py(146):         authkey=process.current_process().authkey,
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: authkey
process.py(206):         return self._config['authkey']
spawn.py(149):     if util._logger is not None:
spawn.py(152):     sys_path=sys.path.copy()
spawn.py(153):     try:
spawn.py(154):         i = sys_path.index('')
spawn.py(158):         sys_path[i] = process.ORIGINAL_DIR
spawn.py(160):     d.update(
spawn.py(161):         name=name,
spawn.py(162):         sys_path=sys_path,
spawn.py(163):         sys_argv=sys.argv,
spawn.py(164):         orig_dir=process.ORIGINAL_DIR,
spawn.py(165):         dir=os.getcwd(),
spawn.py(166):         start_method=get_start_method(),
 --- modulename: context, funcname: get_start_method
context.py(249):         if self._actual_context is None:
context.py(253):         return self._actual_context._name
spawn.py(171):     main_module = sys.modules['__main__']
spawn.py(172):     main_mod_name = getattr(main_module.__spec__, "name", None)
spawn.py(173):     if main_mod_name is not None:
spawn.py(174):         d['init_main_from_name'] = main_mod_name
spawn.py(183):     return d
popen_spawn_win32.py(50):         rhandle, whandle = _winapi.CreatePipe(None, 0)
popen_spawn_win32.py(51):         wfd = msvcrt.open_osfhandle(whandle, 0)
popen_spawn_win32.py(52):         cmd = spawn.get_command_line(parent_pid=os.getpid(),
popen_spawn_win32.py(53):                                      pipe_handle=rhandle)
 --- modulename: spawn, funcname: get_command_line
spawn.py(82):     if getattr(sys, 'frozen', False):
spawn.py(86):         prog = 'from multiprocessing.spawn import spawn_main; spawn_main(%s)'
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
spawn.py(88):         opts = util._args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _args_from_interpreter_flags
subprocess.py(260):         'debug': 'd',
subprocess.py(263):         'dont_write_bytecode': 'B',
subprocess.py(264):         'no_site': 'S',
subprocess.py(265):         'verbose': 'v',
subprocess.py(266):         'bytes_warning': 'b',
subprocess.py(267):         'quiet': 'q',
subprocess.py(270):     args = _optim_args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _optim_args_from_interpreter_flags
subprocess.py(249):     args = []
subprocess.py(250):     value = sys.flags.optimize
subprocess.py(251):     if value > 0:
subprocess.py(253):     return args
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(276):     if sys.flags.isolated:
subprocess.py(279):         if sys.flags.ignore_environment:
subprocess.py(281):         if sys.flags.no_user_site:
subprocess.py(285):     warnopts = sys.warnoptions[:]
subprocess.py(286):     bytes_warning = sys.flags.bytes_warning
subprocess.py(287):     xoptions = getattr(sys, '_xoptions', {})
subprocess.py(288):     dev_mode = ('dev' in xoptions)
subprocess.py(290):     if bytes_warning > 1:
subprocess.py(292):     elif bytes_warning:
subprocess.py(294):     if dev_mode:
subprocess.py(296):     for opt in warnopts:
subprocess.py(300):     if dev_mode:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(312):     return args
spawn.py(89):         return [_python_exe] + opts + ['-c', prog, '--multiprocessing-fork']
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
popen_spawn_win32.py(56):         python_exe = spawn.get_executable()
 --- modulename: spawn, funcname: get_executable
spawn.py(46):     return _python_exe
popen_spawn_win32.py(60):         if WINENV and _path_eq(python_exe, sys.executable):
popen_spawn_win32.py(65):             env = None
popen_spawn_win32.py(67):         with open(wfd, 'wb', closefd=True) as to_child:
popen_spawn_win32.py(69):             try:
popen_spawn_win32.py(70):                 hp, ht, pid, tid = _winapi.CreateProcess(
popen_spawn_win32.py(71):                     python_exe, cmd,
popen_spawn_win32.py(72):                     env, None, False, 0, None, None, None)
popen_spawn_win32.py(73):                 _winapi.CloseHandle(ht)
popen_spawn_win32.py(79):             self.pid = pid
popen_spawn_win32.py(80):             self.returncode = None
popen_spawn_win32.py(81):             self._handle = hp
popen_spawn_win32.py(82):             self.sentinel = int(hp)
popen_spawn_win32.py(83):             self.finalizer = util.Finalize(self, _winapi.CloseHandle, (self.sentinel,))
 --- modulename: util, funcname: __init__
util.py(152):         if (exitpriority is not None) and not isinstance(exitpriority,int):
util.py(157):         if obj is not None:
util.py(158):             self._weakref = weakref.ref(obj, self)
util.py(162):         self._callback = callback
util.py(163):         self._args = args
util.py(164):         self._kwargs = kwargs or {}
util.py(165):         self._key = (exitpriority, next(_finalizer_counter))
util.py(166):         self._pid = os.getpid()
util.py(168):         _finalizer_registry[self._key] = self
popen_spawn_win32.py(86):             set_spawning_popen(self)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
popen_spawn_win32.py(87):             try:
popen_spawn_win32.py(88):                 reduction.dump(prep_data, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
popen_spawn_win32.py(89):                 reduction.dump(process_obj, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
 --- modulename: queues, funcname: __getstate__
queues.py(58):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(59):         return (self._ignore_epipe, self._maxsize, self._reader, self._writer,
queues.py(60):                 self._rlock, self._wlock, self._sem, self._opid)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: queues, funcname: __getstate__
queues.py(343):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(344):         return (self._reader, self._writer, self._rlock, self._wlock)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
popen_spawn_win32.py(91):                 set_spawning_popen(None)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
process.py(113):         self._sentinel = self._popen.sentinel
process.py(116):         del self._target, self._args, self._kwargs
process.py(117):         _children.add(self)
process.py(608):             self._processes[p.pid] = p
 --- modulename: process, funcname: ident
process.py(230):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(231):         if self is _current_process:
process.py(234):             return self._popen and self._popen.pid
process.py(600):         for _ in range(len(self._processes), self._max_workers):
process.py(601):             p = self._mp_context.Process(
process.py(602):                 target=_process_worker,
process.py(603):                 args=(self._call_queue,
process.py(604):                       self._result_queue,
process.py(605):                       self._initializer,
process.py(606):                       self._initargs))
 --- modulename: process, funcname: __init__
process.py(74):         assert group is None, 'group argument must be None for now'
process.py(75):         count = next(_process_counter)
process.py(76):         self._identity = _current_process._identity + (count,)
process.py(77):         self._config = _current_process._config.copy()
process.py(78):         self._parent_pid = os.getpid()
process.py(79):         self._popen = None
process.py(80):         self._closed = False
process.py(81):         self._target = target
process.py(82):         self._args = tuple(args)
process.py(83):         self._kwargs = dict(kwargs)
process.py(84):         self._name = name or type(self).__name__ + '-' + \
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
 --- modulename: process, funcname: <genexpr>
process.py(85):                      ':'.join(str(i) for i in self._identity)
process.py(86):         if daemon is not None:
process.py(88):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
process.py(607):             p.start()
 --- modulename: process, funcname: start
process.py(105):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(106):         assert self._popen is None, 'cannot start a process twice'
process.py(107):         assert self._parent_pid == os.getpid(), \
process.py(109):         assert not _current_process._config.get('daemon'), \
process.py(111):         _cleanup()
 --- modulename: process, funcname: _cleanup
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(56):         if p._popen.poll() is not None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(55):     for p in list(_children):
process.py(112):         self._popen = self._Popen(self)
 --- modulename: context, funcname: _Popen
context.py(321):             from .popen_spawn_win32 import Popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): context.py(322):             return Popen(process_obj)
 --- modulename: popen_spawn_win32, funcname: __init__
popen_spawn_win32.py(46):         prep_data = spawn.get_preparation_data(process_obj._name)
 --- modulename: spawn, funcname: get_preparation_data
spawn.py(143):     _check_not_importing_main()
 --- modulename: spawn, funcname: _check_not_importing_main
spawn.py(122):     if getattr(process.current_process(), '_inheriting', False):
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
spawn.py(144):     d = dict(
spawn.py(145):         log_to_stderr=util._log_to_stderr,
spawn.py(146):         authkey=process.current_process().authkey,
 --- modulename: process, funcname: current_process
process.py(40):     return _current_process
 --- modulename: process, funcname: authkey
process.py(206):         return self._config['authkey']
spawn.py(149):     if util._logger is not None:
spawn.py(152):     sys_path=sys.path.copy()
spawn.py(153):     try:
spawn.py(154):         i = sys_path.index('')
spawn.py(158):         sys_path[i] = process.ORIGINAL_DIR
spawn.py(160):     d.update(
spawn.py(161):         name=name,
spawn.py(162):         sys_path=sys_path,
spawn.py(163):         sys_argv=sys.argv,
spawn.py(164):         orig_dir=process.ORIGINAL_DIR,
spawn.py(165):         dir=os.getcwd(),
spawn.py(166):         start_method=get_start_method(),
 --- modulename: context, funcname: get_start_method
context.py(249):         if self._actual_context is None:
context.py(253):         return self._actual_context._name
spawn.py(171):     main_module = sys.modules['__main__']
spawn.py(172):     main_mod_name = getattr(main_module.__spec__, "name", None)
spawn.py(173):     if main_mod_name is not None:
spawn.py(174):         d['init_main_from_name'] = main_mod_name
spawn.py(183):     return d
popen_spawn_win32.py(50):         rhandle, whandle = _winapi.CreatePipe(None, 0)
popen_spawn_win32.py(51):         wfd = msvcrt.open_osfhandle(whandle, 0)
popen_spawn_win32.py(52):         cmd = spawn.get_command_line(parent_pid=os.getpid(),
popen_spawn_win32.py(53):                                      pipe_handle=rhandle)
 --- modulename: spawn, funcname: get_command_line
spawn.py(82):     if getattr(sys, 'frozen', False):
spawn.py(86):         prog = 'from multiprocessing.spawn import spawn_main; spawn_main(%s)'
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
 --- modulename: spawn, funcname: <genexpr>
spawn.py(87):         prog %= ', '.join('%s=%r' % item for item in kwds.items())
spawn.py(88):         opts = util._args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _args_from_interpreter_flags
subprocess.py(260):         'debug': 'd',
subprocess.py(263):         'dont_write_bytecode': 'B',
subprocess.py(264):         'no_site': 'S',
subprocess.py(265):         'verbose': 'v',
subprocess.py(266):         'bytes_warning': 'b',
subprocess.py(267):         'quiet': 'q',
subprocess.py(270):     args = _optim_args_from_interpreter_flags()
 --- modulename: subprocess, funcname: _optim_args_from_interpreter_flags
subprocess.py(249):     args = []
subprocess.py(250):     value = sys.flags.optimize
subprocess.py(251):     if value > 0:
subprocess.py(253):     return args
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(272):         v = getattr(sys.flags, flag)
subprocess.py(273):         if v > 0:
subprocess.py(271):     for flag, opt in flag_opt_map.items():
subprocess.py(276):     if sys.flags.isolated:
subprocess.py(279):         if sys.flags.ignore_environment:
subprocess.py(281):         if sys.flags.no_user_site:
subprocess.py(285):     warnopts = sys.warnoptions[:]
subprocess.py(286):     bytes_warning = sys.flags.bytes_warning
subprocess.py(287):     xoptions = getattr(sys, '_xoptions', {})
subprocess.py(288):     dev_mode = ('dev' in xoptions)
subprocess.py(290):     if bytes_warning > 1:
subprocess.py(292):     elif bytes_warning:
subprocess.py(294):     if dev_mode:
subprocess.py(296):     for opt in warnopts:
subprocess.py(300):     if dev_mode:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(304):         if opt in xoptions:
subprocess.py(302):     for opt in ('faulthandler', 'tracemalloc', 'importtime',
subprocess.py(312):     return args
spawn.py(89):         return [_python_exe] + opts + ['-c', prog, '--multiprocessing-fork']
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
 --- modulename: popen_spawn_win32, funcname: <genexpr>
popen_spawn_win32.py(54):         cmd = ' '.join('"%s"' % x for x in cmd)
popen_spawn_win32.py(56):         python_exe = spawn.get_executable()
 --- modulename: spawn, funcname: get_executable
spawn.py(46):     return _python_exe
popen_spawn_win32.py(60):         if WINENV and _path_eq(python_exe, sys.executable):
popen_spawn_win32.py(65):             env = None
popen_spawn_win32.py(67):         with open(wfd, 'wb', closefd=True) as to_child:
popen_spawn_win32.py(69):             try:
popen_spawn_win32.py(70):                 hp, ht, pid, tid = _winapi.CreateProcess(
popen_spawn_win32.py(71):                     python_exe, cmd,
popen_spawn_win32.py(72):                     env, None, False, 0, None, None, None)
popen_spawn_win32.py(73):                 _winapi.CloseHandle(ht)
popen_spawn_win32.py(79):             self.pid = pid
popen_spawn_win32.py(80):             self.returncode = None
popen_spawn_win32.py(81):             self._handle = hp
popen_spawn_win32.py(82):             self.sentinel = int(hp)
popen_spawn_win32.py(83):             self.finalizer = util.Finalize(self, _winapi.CloseHandle, (self.sentinel,))
 --- modulename: util, funcname: __init__
util.py(152):         if (exitpriority is not None) and not isinstance(exitpriority,int):
util.py(157):         if obj is not None:
util.py(158):             self._weakref = weakref.ref(obj, self)
util.py(162):         self._callback = callback
util.py(163):         self._args = args
util.py(164):         self._kwargs = kwargs or {}
util.py(165):         self._key = (exitpriority, next(_finalizer_counter))
util.py(166):         self._pid = os.getpid()
util.py(168):         _finalizer_registry[self._key] = self
popen_spawn_win32.py(86):             set_spawning_popen(self)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
popen_spawn_win32.py(87):             try:
popen_spawn_win32.py(88):                 reduction.dump(prep_data, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
popen_spawn_win32.py(89):                 reduction.dump(process_obj, to_child)
 --- modulename: reduction, funcname: dump
reduction.py(60):     ForkingPickler(file, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: process, funcname: __reduce__
process.py(327):         from .context import get_spawning_popen
 --- modulename: _bootstrap, funcname: parent
<frozen importlib._bootstrap>(419): <frozen importlib._bootstrap>(420):  --- modulename: _bootstrap, funcname: _handle_fromlist
<frozen importlib._bootstrap>(1019): <frozen importlib._bootstrap>(1044): process.py(328):         if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
process.py(333):         return AuthenticationString, (bytes(self),)
 --- modulename: queues, funcname: __getstate__
queues.py(58):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(59):         return (self._ignore_epipe, self._maxsize, self._reader, self._writer,
queues.py(60):                 self._rlock, self._wlock, self._sem, self._opid)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
 --- modulename: queues, funcname: __getstate__
queues.py(343):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
queues.py(344):         return (self._reader, self._writer, self._rlock, self._wlock)
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: connection, funcname: reduce_pipe_connection
connection.py(946):         access = ((_winapi.FILE_GENERIC_READ if conn.readable else 0) |
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
connection.py(947):                   (_winapi.FILE_GENERIC_WRITE if conn.writable else 0))
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
connection.py(948):         dh = reduction.DupHandle(conn.fileno(), access)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
 --- modulename: reduction, funcname: __init__
reduction.py(103):             if pid is None:
reduction.py(106):                 pid = os.getpid()
reduction.py(107):             proc = _winapi.OpenProcess(_winapi.PROCESS_DUP_HANDLE, False, pid)
reduction.py(108):             try:
reduction.py(109):                 self._handle = _winapi.DuplicateHandle(
reduction.py(110):                     _winapi.GetCurrentProcess(),
reduction.py(111):                     handle, proc, access, False, 0)
reduction.py(113):                 _winapi.CloseHandle(proc)
reduction.py(114):             self._access = access
reduction.py(115):             self._pid = pid
connection.py(949):         return rebuild_pipe_connection, (dh, conn.readable, conn.writable)
 --- modulename: connection, funcname: readable
connection.py(161):         return self._readable
 --- modulename: connection, funcname: writable
connection.py(166):         return self._writable
 --- modulename: synchronize, funcname: __getstate__
synchronize.py(101):         context.assert_spawning(self)
 --- modulename: context, funcname: assert_spawning
context.py(353):     if get_spawning_popen() is None:
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
synchronize.py(102):         sl = self._semlock
synchronize.py(103):         if sys.platform == 'win32':
synchronize.py(104):             h = context.get_spawning_popen().duplicate_for_child(sl.handle)
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
 --- modulename: popen_spawn_win32, funcname: duplicate_for_child
popen_spawn_win32.py(94):         assert self is get_spawning_popen()
 --- modulename: context, funcname: get_spawning_popen
context.py(347):     return getattr(_tls, 'spawning_popen', None)
popen_spawn_win32.py(95):         return reduction.duplicate(handle, self.sentinel)
 --- modulename: reduction, funcname: duplicate
reduction.py(73):         if target_process is None:
reduction.py(75):         return _winapi.DuplicateHandle(
reduction.py(76):             _winapi.GetCurrentProcess(), handle, target_process,
reduction.py(77):             0, inheritable, _winapi.DUPLICATE_SAME_ACCESS)
synchronize.py(107):         return (h, sl.kind, sl.maxvalue, sl.name)
popen_spawn_win32.py(91):                 set_spawning_popen(None)
 --- modulename: context, funcname: set_spawning_popen
context.py(350):     _tls.spawning_popen = popen
process.py(113):         self._sentinel = self._popen.sentinel
process.py(116):         del self._target, self._args, self._kwargs
process.py(117):         _children.add(self)
process.py(608):             self._processes[p.pid] = p
 --- modulename: process, funcname: ident
process.py(230):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(231):         if self is _current_process:
process.py(234):             return self._popen and self._popen.pid
process.py(600):         for _ in range(len(self._processes), self._max_workers):
process.py(584):             self._queue_management_thread = threading.Thread(
process.py(585):                 target=_queue_management_worker,
process.py(586):                 args=(weakref.ref(self, weakref_cb),
process.py(587):                       self._processes,
process.py(588):                       self._pending_work_items,
process.py(589):                       self._work_ids,
process.py(590):                       self._call_queue,
process.py(591):                       self._result_queue,
process.py(592):                       self._queue_management_thread_wakeup),
process.py(593):                 name="QueueManagerThread")
 --- modulename: threading, funcname: __init__
threading.py(786):         assert group is None, "group argument must be None for now"
threading.py(787):         if kwargs is None:
threading.py(788):             kwargs = {}
threading.py(789):         self._target = target
threading.py(790):         self._name = str(name or _newname())
threading.py(791):         self._args = args
threading.py(792):         self._kwargs = kwargs
threading.py(793):         if daemon is not None:
threading.py(796):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1129):         assert self._initialized, "Thread.__init__() not called"
threading.py(1130):         return self._daemonic
threading.py(797):         self._ident = None
threading.py(798):         self._tstate_lock = None
threading.py(799):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(800):         self._is_stopped = False
threading.py(801):         self._initialized = True
threading.py(804):         self._stderr = _sys.stderr
threading.py(806):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
process.py(594):             self._queue_management_thread.daemon = True
 --- modulename: threading, funcname: daemon
threading.py(1134):         if not self._initialized:
threading.py(1136):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1138):         self._daemonic = daemonic
process.py(595):             self._queue_management_thread.start()
 --- modulename: threading, funcname: start
threading.py(844):         if not self._initialized:
threading.py(847):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(849):         with _active_limbo_lock:
threading.py(850):             _limbo[self] = self
threading.py(851):         try:
threading.py(852):             _start_new_thread(self._bootstrap, ())
threading.py(857):         self._started.wait()
 --- modulename: threading, funcname: wait
 --- modulename: threading, funcname: run
threading.py(549):         with self._cond:
threading.py(868):         try:
 --- modulename: threading, funcname: __enter__
threading.py(869):             if self._target:
threading.py(241):         return self._lock.__enter__()
threading.py(870):                 self._target(*self._args, **self._kwargs)
threading.py(550):             signaled = self._flag
 --- modulename: process, funcname: _queue_management_worker
threading.py(551):             if not signaled:
process.py(317):     executor = None
threading.py(553):             return signaled
process.py(319):     def shutting_down():
 --- modulename: threading, funcname: __exit__
process.py(323):     def shutdown_worker():
threading.py(244):         return self._lock.__exit__(*args)
process.py(346):     result_reader = result_queue._reader
process.py(597):                 self._queue_management_thread_wakeup
process.py(347):     wakeup_reader = thread_wakeup._reader
 --- modulename: weakref, funcname: __setitem__
process.py(348):     readers = [result_reader, wakeup_reader]
weakref.py(409):         self.data[ref(key, self._remove)] = value
process.py(642):             return f
_base.py(587):         fs = [self.submit(fn, *args) for args in zip(*iterables)]
process.py(350):     while True:
 --- modulename: process, funcname: _get_chunks
process.py(184):         chunk = tuple(itertools.islice(it, chunksize))
process.py(351):         _add_call_item_to_queue(pending_work_items,
process.py(185):         if not chunk:
process.py(352):                                 work_ids_queue,
process.py(187):         yield chunk
process.py(353):                                 call_queue)
 --- modulename: process, funcname: submit
 --- modulename: process, funcname: _add_call_item_to_queue
process.py(611):         if len(args) >= 2:
process.py(268):     while True:
process.py(612):             self, fn, *args = args
process.py(269):         if call_queue.full():
process.py(623):         with self._shutdown_lock:
 --- modulename: queues, funcname: full
process.py(624):             if self._broken:
queues.py(123):         return self._sem._semlock._is_zero()
process.py(626):             if self._shutdown_thread:
process.py(271):         try:
process.py(628):             if _global_shutdown:
process.py(272):             work_id = work_ids.get(block=False)
process.py(632):             f = _base.Future()
 --- modulename: queue, funcname: get
 --- modulename: _base, funcname: __init__
queue.py(164):         with self.not_empty:
_base.py(314):         self._condition = threading.Condition()
 --- modulename: threading, funcname: __enter__
 --- modulename: threading, funcname: __init__
threading.py(241):         return self._lock.__enter__()
threading.py(217):         if lock is None:
queue.py(165):             if not block:
threading.py(218):             lock = RLock()
queue.py(166):                 if not self._qsize():
 --- modulename: threading, funcname: RLock
 --- modulename: queue, funcname: _qsize
threading.py(84):     if _CRLock is None:
queue.py(209):         return len(self.queue)
threading.py(86):     return _CRLock(*args, **kwargs)
queue.py(180):             item = self._get()
threading.py(219):         self._lock = lock
 --- modulename: queue, funcname: _get
threading.py(221):         self.acquire = lock.acquire
queue.py(217):         return self.queue.popleft()
threading.py(222):         self.release = lock.release
queue.py(181):             self.not_full.notify()
threading.py(226):         try:
 --- modulename: threading, funcname: notify
threading.py(227):             self._release_save = lock._release_save
threading.py(345):         if not self._is_owned():
threading.py(230):         try:
 --- modulename: threading, funcname: _is_owned
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(258):         if self._lock.acquire(0):
threading.py(234):         try:
threading.py(262):             return True
threading.py(235):             self._is_owned = lock._is_owned
threading.py(347):         all_waiters = self._waiters
threading.py(238):         self._waiters = _deque()
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
_base.py(315):         self._state = PENDING
threading.py(349):         if not waiters_to_notify:
_base.py(316):         self._result = None
threading.py(350):             return
_base.py(317):         self._exception = None
queue.py(182):             return item
_base.py(318):         self._waiters = []
 --- modulename: threading, funcname: __exit__
_base.py(319):         self._done_callbacks = []
threading.py(244):         return self._lock.__exit__(*args)
process.py(633):             w = _WorkItem(f, fn, args, kwargs)
process.py(276):             work_item = pending_work_items[work_id]
 --- modulename: process, funcname: __init__
process.py(278):             if work_item.future.set_running_or_notify_cancel():
process.py(142):         self.future = future
 --- modulename: _base, funcname: set_running_or_notify_cancel
process.py(143):         self.fn = fn
_base.py(496):         with self._condition:
process.py(144):         self.args = args
 --- modulename: threading, funcname: __enter__
process.py(145):         self.kwargs = kwargs
threading.py(241):         return self._lock.__enter__()
process.py(635):             self._pending_work_items[self._queue_count] = w
_base.py(497):             if self._state == CANCELLED:
process.py(636):             self._work_ids.put(self._queue_count)
_base.py(504):             elif self._state == PENDING:
 --- modulename: queue, funcname: put
_base.py(505):                 self._state = RUNNING
queue.py(132):         with self.not_full:
_base.py(506):                 return True
 --- modulename: threading, funcname: __enter__
 --- modulename: threading, funcname: __exit__
threading.py(241):         return self._lock.__enter__()
threading.py(244):         return self._lock.__exit__(*args)
queue.py(133):             if self.maxsize > 0:
process.py(279):                 call_queue.put(_CallItem(work_id,
queue.py(149):             self._put(item)
process.py(280):                                          work_item.fn,
 --- modulename: queue, funcname: _put
process.py(281):                                          work_item.args,
queue.py(213):         self.queue.append(item)
process.py(282):                                          work_item.kwargs),
queue.py(150):             self.unfinished_tasks += 1
 --- modulename: process, funcname: __init__
queue.py(151):             self.not_empty.notify()
process.py(155):         self.work_id = work_id
 --- modulename: threading, funcname: notify
process.py(156):         self.fn = fn
threading.py(345):         if not self._is_owned():
process.py(157):         self.args = args
 --- modulename: threading, funcname: _is_owned
process.py(158):         self.kwargs = kwargs
threading.py(258):         if self._lock.acquire(0):
process.py(283):                                block=True)
threading.py(262):             return True
 --- modulename: queues, funcname: put
threading.py(347):         all_waiters = self._waiters
queues.py(81):         assert not self._closed, "Queue {0!r} has been closed".format(self)
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
queues.py(82):         if not self._sem.acquire(block, timeout):
threading.py(349):         if not waiters_to_notify:
threading.py(350):             return
queues.py(85):         with self._notempty:
 --- modulename: threading, funcname: __exit__
 --- modulename: threading, funcname: __enter__
threading.py(244):         return self._lock.__exit__(*args)
threading.py(241):         return self._lock.__enter__()
process.py(637):             self._queue_count += 1
queues.py(86):             if self._thread is None:
process.py(639):             self._queue_management_thread_wakeup.wakeup()
queues.py(87):                 self._start_thread()
 --- modulename: process, funcname: wakeup
 --- modulename: queues, funcname: _start_thread
process.py(90):         self._writer.send_bytes(b"")
queues.py(156):         debug('Queue._start_thread()')
 --- modulename: connection, funcname: send_bytes
 --- modulename: util, funcname: debug
connection.py(183):         self._check_closed()
util.py(49):     if _logger:
 --- modulename: connection, funcname: _check_closed
queues.py(159):         self._buffer.clear()
connection.py(135):         if self._handle is None:
queues.py(160):         self._thread = threading.Thread(
connection.py(184):         self._check_writable()
queues.py(161):             target=Queue._feed,
 --- modulename: connection, funcname: _check_writable
queues.py(162):             args=(self._buffer, self._notempty, self._send_bytes,
connection.py(143):         if not self._writable:
queues.py(163):                   self._wlock, self._writer.close, self._ignore_epipe,
connection.py(185):         m = memoryview(buf)
queues.py(164):                   self._on_queue_feeder_error, self._sem),
connection.py(187):         if m.itemsize > 1:
queues.py(165):             name='QueueFeederThread'
connection.py(189):         n = len(m)
 --- modulename: threading, funcname: __init__
threading.py(786):         assert group is None, "group argument must be None for now"
connection.py(190):         if offset < 0:
threading.py(787):         if kwargs is None:
connection.py(192):         if n < offset:
threading.py(788):             kwargs = {}
connection.py(194):         if size is None:
threading.py(789):         self._target = target
connection.py(195):             size = n - offset
threading.py(790):         self._name = str(name or _newname())
connection.py(200):         self._send_bytes(m[offset:offset + size])
threading.py(791):         self._args = args
 --- modulename: connection, funcname: _send_bytes
threading.py(792):         self._kwargs = kwargs
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
threading.py(793):         if daemon is not None:
connection.py(281):             try:
threading.py(796):             self._daemonic = current_thread().daemon
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
 --- modulename: threading, funcname: current_thread
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
threading.py(1233):     try:
connection.py(291):             assert err == 0
threading.py(1234):         return _active[get_ident()]
connection.py(292):             assert nwritten == len(buf)
 --- modulename: threading, funcname: daemon
process.py(641):             self._start_queue_management_thread()
threading.py(1129):         assert self._initialized, "Thread.__init__() not called"
 --- modulename: process, funcname: _start_queue_management_thread
threading.py(1130):         return self._daemonic
process.py(573):         if self._queue_management_thread is None:
threading.py(797):         self._ident = None
process.py(642):             return f
threading.py(798):         self._tstate_lock = None
_base.py(587):         fs = [self.submit(fn, *args) for args in zip(*iterables)]
threading.py(799):         self._started = Event()
 --- modulename: process, funcname: _get_chunks
 --- modulename: threading, funcname: __init__
process.py(184):         chunk = tuple(itertools.islice(it, chunksize))
threading.py(500):         self._cond = Condition(Lock())
process.py(185):         if not chunk:
 --- modulename: threading, funcname: __init__
process.py(186):             return
threading.py(217):         if lock is None:
_base.py(591):         def result_iterator():
threading.py(219):         self._lock = lock
_base.py(604):         return result_iterator()
threading.py(221):         self.acquire = lock.acquire
process.py(672):         return _chain_from_iterable_of_lists(results)
threading.py(222):         self.release = lock.release
 --- modulename: _base, funcname: __exit__
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
_base.py(623):         self.shutdown(wait=True)
threading.py(228):         except AttributeError:
 --- modulename: process, funcname: shutdown
threading.py(229):             pass
process.py(675):         with self._shutdown_lock:
threading.py(230):         try:
process.py(676):             self._shutdown_thread = True
threading.py(231):             self._acquire_restore = lock._acquire_restore
process.py(677):         if self._queue_management_thread:
threading.py(232):         except AttributeError:
process.py(679):             self._queue_management_thread_wakeup.wakeup()
 --- modulename: process, funcname: wakeup
threading.py(233):             pass
threading.py(234):         try:
process.py(90):         self._writer.send_bytes(b"")
threading.py(235):             self._is_owned = lock._is_owned
 --- modulename: connection, funcname: send_bytes
threading.py(236):         except AttributeError:
connection.py(183):         self._check_closed()
threading.py(237):             pass
 --- modulename: connection, funcname: _check_closed
threading.py(238):         self._waiters = _deque()
connection.py(135):         if self._handle is None:
threading.py(501):         self._flag = False
connection.py(184):         self._check_writable()
threading.py(800):         self._is_stopped = False
 --- modulename: connection, funcname: _check_writable
threading.py(801):         self._initialized = True
connection.py(143):         if not self._writable:
threading.py(804):         self._stderr = _sys.stderr
connection.py(185):         m = memoryview(buf)
threading.py(806):         _dangling.add(self)
connection.py(187):         if m.itemsize > 1:
 --- modulename: _weakrefset, funcname: add
connection.py(189):         n = len(m)
_weakrefset.py(82):         if self._pending_removals:
connection.py(190):         if offset < 0:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
connection.py(192):         if n < offset:
queues.py(167):         self._thread.daemon = True
connection.py(194):         if size is None:
 --- modulename: threading, funcname: daemon
connection.py(195):             size = n - offset
threading.py(1134):         if not self._initialized:
connection.py(200):         self._send_bytes(m[offset:offset + size])
threading.py(1136):         if self._started.is_set():
 --- modulename: connection, funcname: _send_bytes
 --- modulename: threading, funcname: is_set
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
threading.py(509):         return self._flag
connection.py(281):             try:
threading.py(1138):         self._daemonic = daemonic
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
queues.py(169):         debug('doing self._thread.start()')
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
 --- modulename: util, funcname: debug
connection.py(291):             assert err == 0
util.py(49):     if _logger:
connection.py(292):             assert nwritten == len(buf)
queues.py(170):         self._thread.start()
process.py(680):             if wait:
 --- modulename: threading, funcname: start
process.py(681):                 self._queue_management_thread.join()
threading.py(844):         if not self._initialized:
 --- modulename: threading, funcname: join
threading.py(847):         if self._started.is_set():
threading.py(1036):         if not self._initialized:
 --- modulename: threading, funcname: is_set
threading.py(1038):         if not self._started.is_set():
threading.py(509):         return self._flag
 --- modulename: threading, funcname: is_set
threading.py(849):         with _active_limbo_lock:
threading.py(509):         return self._flag
threading.py(850):             _limbo[self] = self
threading.py(1040):         if self is current_thread():
threading.py(851):         try:
 --- modulename: threading, funcname: current_thread
threading.py(852):             _start_new_thread(self._bootstrap, ())
threading.py(1233):     try:
threading.py(857):         self._started.wait()
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: wait
threading.py(1043):         if timeout is None:
threading.py(549):         with self._cond:
threading.py(1044):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: __enter__
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(241):         return self._lock.__enter__()
threading.py(1057):         lock = self._tstate_lock
threading.py(550):             signaled = self._flag
threading.py(1058):         if lock is None:  # already determined that the C code is done
threading.py(551):             if not signaled:
threading.py(1060):         elif lock.acquire(block, timeout):
threading.py(553):             return signaled
 --- modulename: threading, funcname: run
 --- modulename: threading, funcname: __exit__
threading.py(868):         try:
threading.py(244):         return self._lock.__exit__(*args)
threading.py(869):             if self._target:
queues.py(171):         debug('... done self._thread.start()')
threading.py(870):                 self._target(*self._args, **self._kwargs)
 --- modulename: util, funcname: debug
 --- modulename: queues, funcname: _feed
util.py(49):     if _logger:
queues.py(207):         debug('starting thread to feed data to pipe')
queues.py(173):         if not self._joincancelled:
 --- modulename: util, funcname: debug
queues.py(174):             self._jointhread = Finalize(
util.py(49):     if _logger:
queues.py(175):                 self._thread, Queue._finalize_join,
queues.py(208):         nacquire = notempty.acquire
queues.py(176):                 [weakref.ref(self._thread)],
queues.py(209):         nrelease = notempty.release
queues.py(177):                 exitpriority=-5
queues.py(210):         nwait = notempty.wait
 --- modulename: util, funcname: __init__
queues.py(211):         bpopleft = buffer.popleft
util.py(152):         if (exitpriority is not None) and not isinstance(exitpriority,int):
queues.py(212):         sentinel = _sentinel
util.py(157):         if obj is not None:
queues.py(213):         if sys.platform != 'win32':
util.py(158):             self._weakref = weakref.ref(obj, self)
queues.py(217):             wacquire = None
util.py(162):         self._callback = callback
queues.py(219):         while 1:
util.py(163):         self._args = args
queues.py(220):             try:
util.py(164):         self._kwargs = kwargs or {}
queues.py(221):                 nacquire()
util.py(165):         self._key = (exitpriority, next(_finalizer_counter))
util.py(166):         self._pid = os.getpid()
util.py(168):         _finalizer_registry[self._key] = self
queues.py(181):         self._close = Finalize(
queues.py(182):             self, Queue._finalize_close,
queues.py(183):             [self._buffer, self._notempty],
queues.py(184):             exitpriority=10
 --- modulename: util, funcname: __init__
util.py(152):         if (exitpriority is not None) and not isinstance(exitpriority,int):
util.py(157):         if obj is not None:
util.py(158):             self._weakref = weakref.ref(obj, self)
util.py(162):         self._callback = callback
util.py(163):         self._args = args
util.py(164):         self._kwargs = kwargs or {}
util.py(165):         self._key = (exitpriority, next(_finalizer_counter))
util.py(166):         self._pid = os.getpid()
util.py(168):         _finalizer_registry[self._key] = self
queues.py(88):             self._buffer.append(obj)
queues.py(89):             self._notempty.notify()
 --- modulename: threading, funcname: notify
threading.py(345):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(347):         all_waiters = self._waiters
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
threading.py(349):         if not waiters_to_notify:
threading.py(350):             return
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
process.py(269):         if call_queue.full():
queues.py(222):                 try:
 --- modulename: queues, funcname: full
queues.py(223):                     if not buffer:
queues.py(123):         return self._sem._semlock._is_zero()
queues.py(226):                     nrelease()
process.py(271):         try:
queues.py(227):                 try:
process.py(272):             work_id = work_ids.get(block=False)
queues.py(228):                     while 1:
 --- modulename: queue, funcname: get
queues.py(229):                         obj = bpopleft()
queue.py(164):         with self.not_empty:
queues.py(230):                         if obj is sentinel:
 --- modulename: threading, funcname: __enter__
queues.py(236):                         obj = _ForkingPickler.dumps(obj)
threading.py(241):         return self._lock.__enter__()
 --- modulename: reduction, funcname: dumps
queue.py(165):             if not block:
reduction.py(50):         buf = io.BytesIO()
queue.py(166):                 if not self._qsize():
reduction.py(51):         cls(buf, protocol).dump(obj)
 --- modulename: queue, funcname: _qsize
 --- modulename: reduction, funcname: __init__
queue.py(209):         return len(self.queue)
reduction.py(39):         super().__init__(*args)
queue.py(180):             item = self._get()
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
 --- modulename: queue, funcname: _get
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
queue.py(217):         return self.queue.popleft()
 --- modulename: copyreg, funcname: _slotnames
queue.py(181):             self.not_full.notify()
copyreg.py(108):     names = cls.__dict__.get("__slotnames__")
 --- modulename: threading, funcname: notify
copyreg.py(109):     if names is not None:
threading.py(345):         if not self._is_owned():
copyreg.py(113):     names = []
 --- modulename: threading, funcname: _is_owned
copyreg.py(114):     if not hasattr(cls, "__slots__"):
threading.py(258):         if self._lock.acquire(0):
copyreg.py(116):         pass
threading.py(262):             return True
copyreg.py(140):     try:
threading.py(347):         all_waiters = self._waiters
copyreg.py(141):         cls.__slotnames__ = names
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
copyreg.py(145):     return names
threading.py(349):         if not waiters_to_notify:
threading.py(350):             return
 --- modulename: reduction, funcname: _reduce_partial
queue.py(182):             return item
reduction.py(220):     return _rebuild_partial, (p.func, p.args, p.keywords or {})
 --- modulename: threading, funcname: __exit__
 --- modulename: managers, funcname: __reduce__
threading.py(244):         return self._lock.__exit__(*args)
managers.py(896):         kwds = {}
process.py(276):             work_item = pending_work_items[work_id]
managers.py(897):         if get_spawning_popen() is not None:
process.py(278):             if work_item.future.set_running_or_notify_cancel():
 --- modulename: context, funcname: get_spawning_popen
 --- modulename: _base, funcname: set_running_or_notify_cancel
context.py(347):     return getattr(_tls, 'spawning_popen', None)
_base.py(496):         with self._condition:
managers.py(900):         if getattr(self, '_isauto', False):
 --- modulename: threading, funcname: __enter__
managers.py(905):             return (RebuildProxy,
threading.py(241):         return self._lock.__enter__()
managers.py(906):                     (type(self), self._token, self._serializer, kwds))
_base.py(497):             if self._state == CANCELLED:
 --- modulename: managers, funcname: __getstate__
_base.py(504):             elif self._state == PENDING:
managers.py(61):         return (self.typeid, self.address, self.id)
_base.py(505):                 self._state = RUNNING
reduction.py(52):         return buf.getbuffer()
_base.py(506):                 return True
queues.py(237):                         if wacquire is None:
 --- modulename: threading, funcname: __exit__
queues.py(238):                             send_bytes(obj)
threading.py(244):         return self._lock.__exit__(*args)
 --- modulename: connection, funcname: send_bytes
process.py(279):                 call_queue.put(_CallItem(work_id,
connection.py(183):         self._check_closed()
process.py(280):                                          work_item.fn,
 --- modulename: connection, funcname: _check_closed
process.py(281):                                          work_item.args,
connection.py(135):         if self._handle is None:
process.py(282):                                          work_item.kwargs),
connection.py(184):         self._check_writable()
 --- modulename: process, funcname: __init__
 --- modulename: connection, funcname: _check_writable
process.py(155):         self.work_id = work_id
connection.py(143):         if not self._writable:
process.py(156):         self.fn = fn
connection.py(185):         m = memoryview(buf)
process.py(157):         self.args = args
connection.py(187):         if m.itemsize > 1:
process.py(158):         self.kwargs = kwargs
connection.py(189):         n = len(m)
process.py(283):                                block=True)
connection.py(190):         if offset < 0:
 --- modulename: queues, funcname: put
connection.py(192):         if n < offset:
queues.py(81):         assert not self._closed, "Queue {0!r} has been closed".format(self)
connection.py(194):         if size is None:
queues.py(82):         if not self._sem.acquire(block, timeout):
connection.py(195):             size = n - offset
queues.py(85):         with self._notempty:
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: threading, funcname: __enter__
 --- modulename: connection, funcname: _send_bytes
threading.py(241):         return self._lock.__enter__()
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
queues.py(86):             if self._thread is None:
connection.py(281):             try:
queues.py(88):             self._buffer.append(obj)
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
queues.py(89):             self._notempty.notify()
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
 --- modulename: threading, funcname: notify
connection.py(291):             assert err == 0
threading.py(345):         if not self._is_owned():
connection.py(292):             assert nwritten == len(buf)
 --- modulename: threading, funcname: _is_owned
queues.py(229):                         obj = bpopleft()
threading.py(258):         if self._lock.acquire(0):
queues.py(230):                         if obj is sentinel:
threading.py(262):             return True
queues.py(236):                         obj = _ForkingPickler.dumps(obj)
threading.py(347):         all_waiters = self._waiters
 --- modulename: reduction, funcname: dumps
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
reduction.py(50):         buf = io.BytesIO()
threading.py(349):         if not waiters_to_notify:
reduction.py(51):         cls(buf, protocol).dump(obj)
threading.py(350):             return
 --- modulename: reduction, funcname: __init__
 --- modulename: threading, funcname: __exit__
reduction.py(39):         super().__init__(*args)
threading.py(244):         return self._lock.__exit__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
process.py(269):         if call_queue.full():
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
 --- modulename: queues, funcname: full
 --- modulename: reduction, funcname: _reduce_partial
queues.py(123):         return self._sem._semlock._is_zero()
reduction.py(220):     return _rebuild_partial, (p.func, p.args, p.keywords or {})
process.py(271):         try:
 --- modulename: managers, funcname: __reduce__
process.py(272):             work_id = work_ids.get(block=False)
managers.py(896):         kwds = {}
 --- modulename: queue, funcname: get
managers.py(897):         if get_spawning_popen() is not None:
queue.py(164):         with self.not_empty:
 --- modulename: context, funcname: get_spawning_popen
 --- modulename: threading, funcname: __enter__
context.py(347):     return getattr(_tls, 'spawning_popen', None)
threading.py(241):         return self._lock.__enter__()
managers.py(900):         if getattr(self, '_isauto', False):
queue.py(165):             if not block:
managers.py(905):             return (RebuildProxy,
queue.py(166):                 if not self._qsize():
managers.py(906):                     (type(self), self._token, self._serializer, kwds))
 --- modulename: queue, funcname: _qsize
 --- modulename: managers, funcname: __getstate__
queue.py(209):         return len(self.queue)
managers.py(61):         return (self.typeid, self.address, self.id)
queue.py(167):                     raise Empty
reduction.py(52):         return buf.getbuffer()
 --- modulename: threading, funcname: __exit__
queues.py(237):                         if wacquire is None:
threading.py(244):         return self._lock.__exit__(*args)
queues.py(238):                             send_bytes(obj)
process.py(273):         except queue.Empty:
 --- modulename: connection, funcname: send_bytes
process.py(274):             return
connection.py(183):         self._check_closed()
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: connection, funcname: _check_closed
 --- modulename: process, funcname: <listcomp>
connection.py(135):         if self._handle is None:
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
connection.py(184):         self._check_writable()
 --- modulename: process, funcname: sentinel
 --- modulename: connection, funcname: _check_writable
process.py(244):         self._check_closed()
connection.py(143):         if not self._writable:
 --- modulename: process, funcname: _check_closed
connection.py(185):         m = memoryview(buf)
process.py(91):         if self._closed:
connection.py(187):         if m.itemsize > 1:
process.py(245):         try:
connection.py(189):         n = len(m)
process.py(246):             return self._sentinel
connection.py(190):         if offset < 0:
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
connection.py(192):         if n < offset:
 --- modulename: process, funcname: sentinel
connection.py(194):         if size is None:
process.py(244):         self._check_closed()
connection.py(195):             size = n - offset
 --- modulename: process, funcname: _check_closed
connection.py(200):         self._send_bytes(m[offset:offset + size])
process.py(91):         if self._closed:
 --- modulename: connection, funcname: _send_bytes
process.py(245):         try:
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
process.py(246):             return self._sentinel
connection.py(281):             try:
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
 --- modulename: process, funcname: sentinel
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
process.py(244):         self._check_closed()
connection.py(291):             assert err == 0
 --- modulename: process, funcname: _check_closed
connection.py(292):             assert nwritten == len(buf)
process.py(91):         if self._closed:
queues.py(229):                         obj = bpopleft()
process.py(245):         try:
queues.py(245):                 except IndexError:
process.py(246):             return self._sentinel
queues.py(246):                     pass
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
queues.py(220):             try:
 --- modulename: process, funcname: sentinel
queues.py(221):                 nacquire()
process.py(244):         self._check_closed()
queues.py(222):                 try:
 --- modulename: process, funcname: _check_closed
queues.py(223):                     if not buffer:
process.py(91):         if self._closed:
queues.py(224):                         nwait()
process.py(245):         try:
 --- modulename: threading, funcname: wait
process.py(246):             return self._sentinel
threading.py(287):         if not self._is_owned():
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: threading, funcname: _is_owned
process.py(361):         ready = wait(readers + worker_sentinels)
threading.py(258):         if self._lock.acquire(0):
 --- modulename: connection, funcname: wait
threading.py(262):             return True
connection.py(822):         if timeout is None:
threading.py(289):         waiter = _allocate_lock()
connection.py(823):             timeout = INFINITE
threading.py(290):         waiter.acquire()
connection.py(829):         object_list = list(object_list)
threading.py(291):         self._waiters.append(waiter)
connection.py(830):         waithandle_to_obj = {}
threading.py(292):         saved_state = self._release_save()
connection.py(831):         ov_list = []
 --- modulename: threading, funcname: _release_save
connection.py(832):         ready_objects = set()
threading.py(250):         self._lock.release()           # No state to save
connection.py(833):         ready_handles = set()
threading.py(293):         gotit = False
connection.py(835):         try:
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
connection.py(836):             for o in object_list:
threading.py(295):             if timeout is None:
connection.py(837):                 try:
threading.py(296):                 waiter.acquire()
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(856):                         if ov and sys.getwindowsversion()[:2] >= (6, 2):
connection.py(859):                             try:
connection.py(860):                                 _, err = ov.GetOverlappedResult(False)
connection.py(863):                             if not err and hasattr(o, '_got_empty_message'):
connection.py(864):                                 o._got_empty_message = True
connection.py(865):                         ready_objects.add(o)
connection.py(866):                         timeout = 0
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(802):                 break
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(363):         cause = None
process.py(364):         is_broken = True
process.py(365):         if result_reader in ready:
process.py(372):         elif wakeup_reader in ready:
process.py(373):             is_broken = False
process.py(374):             result_item = None
process.py(375):         thread_wakeup.clear()
 --- modulename: process, funcname: clear
process.py(93):         while self._reader.poll():
 --- modulename: connection, funcname: poll
connection.py(255):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(256):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(257):         return self._poll(timeout)
 --- modulename: connection, funcname: _poll
connection.py(327):             if (self._got_empty_message or
connection.py(329):                 return True
process.py(94):             self._reader.recv_bytes()
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(296):                 self._got_empty_message = False
connection.py(297):                 return io.BytesIO()
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
process.py(93):         while self._reader.poll():
 --- modulename: connection, funcname: poll
connection.py(255):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(256):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(257):         return self._poll(timeout)
 --- modulename: connection, funcname: _poll
connection.py(327):             if (self._got_empty_message or
connection.py(328):                         _winapi.PeekNamedPipe(self._handle)[0] != 0):
connection.py(330):             return bool(wait([self], timeout))
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(824):         elif timeout < 0:
connection.py(827):             timeout = int(timeout * 1000 + 0.5)
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(856):                         if ov and sys.getwindowsversion()[:2] >= (6, 2):
connection.py(859):                             try:
connection.py(860):                                 _, err = ov.GetOverlappedResult(False)
connection.py(863):                             if not err and hasattr(o, '_got_empty_message'):
connection.py(864):                                 o._got_empty_message = True
connection.py(865):                         ready_objects.add(o)
connection.py(866):                         timeout = 0
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(94):             self._reader.recv_bytes()
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(296):                 self._got_empty_message = False
connection.py(297):                 return io.BytesIO()
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
process.py(93):         while self._reader.poll():
 --- modulename: connection, funcname: poll
connection.py(255):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(256):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(257):         return self._poll(timeout)
 --- modulename: connection, funcname: _poll
connection.py(327):             if (self._got_empty_message or
connection.py(328):                         _winapi.PeekNamedPipe(self._handle)[0] != 0):
connection.py(330):             return bool(wait([self], timeout))
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(824):         elif timeout < 0:
connection.py(827):             timeout = int(timeout * 1000 + 0.5)
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(856):                         if ov and sys.getwindowsversion()[:2] >= (6, 2):
connection.py(859):                             try:
connection.py(860):                                 _, err = ov.GetOverlappedResult(False)
connection.py(863):                             if not err and hasattr(o, '_got_empty_message'):
connection.py(864):                                 o._got_empty_message = True
connection.py(865):                         ready_objects.add(o)
connection.py(866):                         timeout = 0
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(94):             self._reader.recv_bytes()
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(296):                 self._got_empty_message = False
connection.py(297):                 return io.BytesIO()
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
process.py(93):         while self._reader.poll():
 --- modulename: connection, funcname: poll
connection.py(255):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(256):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(257):         return self._poll(timeout)
 --- modulename: connection, funcname: _poll
connection.py(327):             if (self._got_empty_message or
connection.py(328):                         _winapi.PeekNamedPipe(self._handle)[0] != 0):
connection.py(330):             return bool(wait([self], timeout))
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(824):         elif timeout < 0:
connection.py(827):             timeout = int(timeout * 1000 + 0.5)
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(802):                 break
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(376):         if is_broken:
process.py(403):         if isinstance(result_item, int):
process.py(412):         elif result_item is not None:
process.py(426):         executor = executor_reference()
process.py(431):         if shutting_down():
 --- modulename: process, funcname: shutting_down
process.py(320):         return (_global_shutdown or executor is None
process.py(321):                 or executor._shutdown_thread)
process.py(432):             try:
process.py(435):                 if executor is not None:
process.py(436):                     executor._shutdown_thread = True
process.py(439):                 if not pending_work_items:
process.py(446):         executor = None
process.py(351):         _add_call_item_to_queue(pending_work_items,
process.py(352):                                 work_ids_queue,
process.py(353):                                 call_queue)
 --- modulename: process, funcname: _add_call_item_to_queue
process.py(268):     while True:
process.py(269):         if call_queue.full():
 --- modulename: queues, funcname: full
queues.py(123):         return self._sem._semlock._is_zero()
process.py(271):         try:
process.py(272):             work_id = work_ids.get(block=False)
 --- modulename: queue, funcname: get
queue.py(164):         with self.not_empty:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
queue.py(165):             if not block:
queue.py(166):                 if not self._qsize():
 --- modulename: queue, funcname: _qsize
queue.py(209):         return len(self.queue)
queue.py(167):                     raise Empty
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
process.py(273):         except queue.Empty:
process.py(274):             return
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: <listcomp>
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
process.py(361):         ready = wait(readers + worker_sentinels)
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(823):             timeout = INFINITE
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(803):             elif WAIT_OBJECT_0 <= res < WAIT_OBJECT_0 + len(L):
connection.py(804):                 res -= WAIT_OBJECT_0
connection.py(809):             ready.append(L[res])
connection.py(810):             L = L[res+1:]
connection.py(811):             timeout = 0
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(802):                 break
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(883):                     o = waithandle_to_obj[ov.event]
connection.py(884):                     ready_objects.add(o)
connection.py(885):                     if err == 0:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(363):         cause = None
process.py(364):         is_broken = True
process.py(365):         if result_reader in ready:
process.py(366):             try:
process.py(367):                 result_item = result_reader.recv()
 --- modulename: connection, funcname: recv
connection.py(248):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(249):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(250):         buf = self._recv_bytes()
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(317):                         elif err == _winapi.ERROR_MORE_DATA:
connection.py(318):                             return self._get_more_data(ov, maxsize)
 --- modulename: connection, funcname: _get_more_data
connection.py(333):             buf = ov.getbuffer()
connection.py(334):             f = io.BytesIO()
connection.py(335):             f.write(buf)
connection.py(336):             left = _winapi.PeekNamedPipe(self._handle)[1]
connection.py(337):             assert left > 0
connection.py(338):             if maxsize is not None and len(buf) + left > maxsize:
connection.py(340):             ov, err = _winapi.ReadFile(self._handle, left, overlapped=True)
connection.py(341):             rbytes, err = ov.GetOverlappedResult(True)
connection.py(342):             assert err == 0
connection.py(343):             assert rbytes == left
connection.py(344):             f.write(ov.getbuffer())
connection.py(345):             return f
connection.py(251):         return _ForkingPickler.loads(buf.getbuffer())
 --- modulename: process, funcname: _rebuild_exc
process.py(137):     exc.__cause__ = _RemoteTraceback(tb)
 --- modulename: process, funcname: __init__
process.py(123):         self.tb = tb
process.py(138):     return exc
process.py(368):                 is_broken = False
process.py(375):         thread_wakeup.clear()
 --- modulename: process, funcname: clear
process.py(93):         while self._reader.poll():
 --- modulename: connection, funcname: poll
connection.py(255):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(256):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(257):         return self._poll(timeout)
 --- modulename: connection, funcname: _poll
connection.py(327):             if (self._got_empty_message or
connection.py(328):                         _winapi.PeekNamedPipe(self._handle)[0] != 0):
connection.py(330):             return bool(wait([self], timeout))
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(824):         elif timeout < 0:
connection.py(827):             timeout = int(timeout * 1000 + 0.5)
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(802):                 break
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(376):         if is_broken:
process.py(403):         if isinstance(result_item, int):
process.py(412):         elif result_item is not None:
process.py(413):             work_item = pending_work_items.pop(result_item.work_id, None)
process.py(415):             if work_item is not None:
process.py(416):                 if result_item.exception:
process.py(417):                     work_item.future.set_exception(result_item.exception)
 --- modulename: _base, funcname: set_exception
_base.py(531):         with self._condition:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
_base.py(532):             self._exception = exception
_base.py(533):             self._state = FINISHED
_base.py(534):             for waiter in self._waiters:
_base.py(536):             self._condition.notify_all()
 --- modulename: threading, funcname: notify_all
threading.py(365):         self.notify(len(self._waiters))
 --- modulename: threading, funcname: notify
threading.py(345):         if not self._is_owned():
threading.py(347):         all_waiters = self._waiters
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
threading.py(349):         if not waiters_to_notify:
threading.py(350):             return
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
_base.py(537):         self._invoke_callbacks()
 --- modulename: _base, funcname: _invoke_callbacks
_base.py(322):         for callback in self._done_callbacks:
process.py(421):                 del work_item
process.py(423):             del result_item
process.py(426):         executor = executor_reference()
process.py(431):         if shutting_down():
 --- modulename: process, funcname: shutting_down
process.py(320):         return (_global_shutdown or executor is None
process.py(321):                 or executor._shutdown_thread)
process.py(432):             try:
process.py(435):                 if executor is not None:
process.py(436):                     executor._shutdown_thread = True
process.py(439):                 if not pending_work_items:
process.py(446):         executor = None
process.py(351):         _add_call_item_to_queue(pending_work_items,
process.py(352):                                 work_ids_queue,
process.py(353):                                 call_queue)
 --- modulename: process, funcname: _add_call_item_to_queue
process.py(268):     while True:
process.py(269):         if call_queue.full():
 --- modulename: queues, funcname: full
queues.py(123):         return self._sem._semlock._is_zero()
process.py(271):         try:
process.py(272):             work_id = work_ids.get(block=False)
 --- modulename: queue, funcname: get
queue.py(164):         with self.not_empty:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
queue.py(165):             if not block:
queue.py(166):                 if not self._qsize():
 --- modulename: queue, funcname: _qsize
queue.py(209):         return len(self.queue)
queue.py(167):                     raise Empty
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
process.py(273):         except queue.Empty:
process.py(274):             return
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: <listcomp>
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
 --- modulename: process, funcname: sentinel
process.py(244):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(245):         try:
process.py(246):             return self._sentinel
process.py(360):         worker_sentinels = [p.sentinel for p in processes.values()]
process.py(361):         ready = wait(readers + worker_sentinels)
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(823):             timeout = INFINITE
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(856):                         if ov and sys.getwindowsversion()[:2] >= (6, 2):
connection.py(859):                             try:
connection.py(860):                                 _, err = ov.GetOverlappedResult(False)
connection.py(863):                             if not err and hasattr(o, '_got_empty_message'):
connection.py(865):                         ready_objects.add(o)
connection.py(866):                         timeout = 0
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(839):                 except AttributeError:
connection.py(840):                     waithandle_to_obj[o.__index__()] = o
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(802):                 break
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(363):         cause = None
process.py(364):         is_broken = True
process.py(365):         if result_reader in ready:
process.py(366):             try:
process.py(367):                 result_item = result_reader.recv()
 --- modulename: connection, funcname: recv
connection.py(248):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(249):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(250):         buf = self._recv_bytes()
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(317):                         elif err == _winapi.ERROR_MORE_DATA:
connection.py(318):                             return self._get_more_data(ov, maxsize)
 --- modulename: connection, funcname: _get_more_data
connection.py(333):             buf = ov.getbuffer()
connection.py(334):             f = io.BytesIO()
connection.py(335):             f.write(buf)
connection.py(336):             left = _winapi.PeekNamedPipe(self._handle)[1]
connection.py(337):             assert left > 0
connection.py(338):             if maxsize is not None and len(buf) + left > maxsize:
connection.py(340):             ov, err = _winapi.ReadFile(self._handle, left, overlapped=True)
connection.py(341):             rbytes, err = ov.GetOverlappedResult(True)
connection.py(342):             assert err == 0
connection.py(343):             assert rbytes == left
connection.py(344):             f.write(ov.getbuffer())
connection.py(345):             return f
connection.py(251):         return _ForkingPickler.loads(buf.getbuffer())
 --- modulename: process, funcname: _rebuild_exc
process.py(137):     exc.__cause__ = _RemoteTraceback(tb)
 --- modulename: process, funcname: __init__
process.py(123):         self.tb = tb
process.py(138):     return exc
process.py(368):                 is_broken = False
process.py(375):         thread_wakeup.clear()
 --- modulename: process, funcname: clear
process.py(93):         while self._reader.poll():
 --- modulename: connection, funcname: poll
connection.py(255):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(256):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(257):         return self._poll(timeout)
 --- modulename: connection, funcname: _poll
connection.py(327):             if (self._got_empty_message or
connection.py(328):                         _winapi.PeekNamedPipe(self._handle)[0] != 0):
connection.py(330):             return bool(wait([self], timeout))
 --- modulename: connection, funcname: wait
connection.py(822):         if timeout is None:
connection.py(824):         elif timeout < 0:
connection.py(827):             timeout = int(timeout * 1000 + 0.5)
connection.py(829):         object_list = list(object_list)
connection.py(830):         waithandle_to_obj = {}
connection.py(831):         ov_list = []
connection.py(832):         ready_objects = set()
connection.py(833):         ready_handles = set()
connection.py(835):         try:
connection.py(836):             for o in object_list:
connection.py(837):                 try:
connection.py(838):                     fileno = getattr(o, 'fileno')
connection.py(843):                     try:
connection.py(844):                         ov, err = _winapi.ReadFile(fileno(), 0, True)
 --- modulename: connection, funcname: fileno
connection.py(170):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(171):         return self._handle
connection.py(849):                     if err == _winapi.ERROR_IO_PENDING:
connection.py(850):                         ov_list.append(ov)
connection.py(851):                         waithandle_to_obj[ov.event] = o
connection.py(836):             for o in object_list:
connection.py(868):             ready_handles = _exhaustive_wait(waithandle_to_obj.keys(), timeout)
 --- modulename: connection, funcname: _exhaustive_wait
connection.py(797):         L = list(handles)
connection.py(798):         ready = []
connection.py(799):         while L:
connection.py(800):             res = _winapi.WaitForMultipleObjects(L, False, timeout)
connection.py(801):             if res == WAIT_TIMEOUT:
connection.py(802):                 break
connection.py(812):         return ready
connection.py(871):             for ov in ov_list:
connection.py(872):                 ov.cancel()
connection.py(871):             for ov in ov_list:
connection.py(875):             for ov in ov_list:
connection.py(876):                 try:
connection.py(877):                     _, err = ov.GetOverlappedResult(True)
connection.py(882):                 if err != _winapi.ERROR_OPERATION_ABORTED:
connection.py(875):             for ov in ov_list:
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
 --- modulename: connection, funcname: <genexpr>
connection.py(891):         ready_objects.update(waithandle_to_obj[h] for h in ready_handles)
connection.py(892):         return [o for o in object_list if o in ready_objects]
 --- modulename: connection, funcname: <listcomp>
connection.py(892):         return [o for o in object_list if o in ready_objects]
connection.py(892):         return [o for o in object_list if o in ready_objects]
process.py(376):         if is_broken:
process.py(403):         if isinstance(result_item, int):
process.py(412):         elif result_item is not None:
process.py(413):             work_item = pending_work_items.pop(result_item.work_id, None)
process.py(415):             if work_item is not None:
process.py(416):                 if result_item.exception:
process.py(417):                     work_item.future.set_exception(result_item.exception)
 --- modulename: _base, funcname: set_exception
_base.py(531):         with self._condition:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
_base.py(532):             self._exception = exception
_base.py(533):             self._state = FINISHED
_base.py(534):             for waiter in self._waiters:
_base.py(536):             self._condition.notify_all()
 --- modulename: threading, funcname: notify_all
threading.py(365):         self.notify(len(self._waiters))
 --- modulename: threading, funcname: notify
threading.py(345):         if not self._is_owned():
threading.py(347):         all_waiters = self._waiters
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
threading.py(349):         if not waiters_to_notify:
threading.py(350):             return
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
_base.py(537):         self._invoke_callbacks()
 --- modulename: _base, funcname: _invoke_callbacks
_base.py(322):         for callback in self._done_callbacks:
process.py(421):                 del work_item
process.py(423):             del result_item
process.py(426):         executor = executor_reference()
process.py(431):         if shutting_down():
 --- modulename: process, funcname: shutting_down
process.py(320):         return (_global_shutdown or executor is None
process.py(321):                 or executor._shutdown_thread)
process.py(432):             try:
process.py(435):                 if executor is not None:
process.py(436):                     executor._shutdown_thread = True
process.py(439):                 if not pending_work_items:
process.py(440):                     shutdown_worker()
 --- modulename: process, funcname: shutdown_worker
process.py(325):         n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: process, funcname: <genexpr>
process.py(325):         n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(158):             return True
 --- modulename: process, funcname: <genexpr>
process.py(325):         n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(158):             return True
 --- modulename: process, funcname: <genexpr>
process.py(325):         n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(158):             return True
 --- modulename: process, funcname: <genexpr>
process.py(325):         n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(158):             return True
 --- modulename: process, funcname: <genexpr>
process.py(325):         n_children_alive = sum(p.is_alive() for p in processes.values())
process.py(326):         n_children_to_stop = n_children_alive
process.py(327):         n_sentinels_sent = 0
process.py(330):         while n_sentinels_sent < n_children_to_stop and n_children_alive > 0:
process.py(331):             for i in range(n_children_to_stop - n_sentinels_sent):
process.py(332):                 try:
process.py(333):                     call_queue.put_nowait(None)
 --- modulename: queues, funcname: put_nowait
queues.py(129):         return self.put(obj, False)
 --- modulename: queues, funcname: put
queues.py(81):         assert not self._closed, "Queue {0!r} has been closed".format(self)
queues.py(82):         if not self._sem.acquire(block, timeout):
queues.py(85):         with self._notempty:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
queues.py(86):             if self._thread is None:
queues.py(88):             self._buffer.append(obj)
queues.py(89):             self._notempty.notify()
 --- modulename: threading, funcname: notify
threading.py(345):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(347):         all_waiters = self._waiters
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
threading.py(349):         if not waiters_to_notify:
threading.py(351):         for waiter in waiters_to_notify:
threading.py(352):             waiter.release()
threading.py(353):             try:
threading.py(297):                 gotit = True
threading.py(354):                 all_waiters.remove(waiter)
threading.py(303):             return gotit
threading.py(351):         for waiter in waiters_to_notify:
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: __exit__
 --- modulename: threading, funcname: _acquire_restore
threading.py(244):         return self._lock.__exit__(*args)
threading.py(253):         self._lock.acquire()           # Ignore saved state
process.py(334):                     n_sentinels_sent += 1
threading.py(306):             if not gotit:
process.py(331):             for i in range(n_children_to_stop - n_sentinels_sent):
queues.py(226):                     nrelease()
process.py(332):                 try:
queues.py(227):                 try:
process.py(333):                     call_queue.put_nowait(None)
queues.py(228):                     while 1:
 --- modulename: queues, funcname: put_nowait
queues.py(229):                         obj = bpopleft()
queues.py(129):         return self.put(obj, False)
queues.py(230):                         if obj is sentinel:
 --- modulename: queues, funcname: put
queues.py(236):                         obj = _ForkingPickler.dumps(obj)
queues.py(81):         assert not self._closed, "Queue {0!r} has been closed".format(self)
 --- modulename: reduction, funcname: dumps
queues.py(82):         if not self._sem.acquire(block, timeout):
reduction.py(50):         buf = io.BytesIO()
queues.py(85):         with self._notempty:
reduction.py(51):         cls(buf, protocol).dump(obj)
 --- modulename: threading, funcname: __enter__
 --- modulename: reduction, funcname: __init__
threading.py(241):         return self._lock.__enter__()
reduction.py(39):         super().__init__(*args)
queues.py(86):             if self._thread is None:
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
queues.py(88):             self._buffer.append(obj)
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
queues.py(89):             self._notempty.notify()
reduction.py(52):         return buf.getbuffer()
 --- modulename: threading, funcname: notify
queues.py(237):                         if wacquire is None:
threading.py(345):         if not self._is_owned():
queues.py(238):                             send_bytes(obj)
 --- modulename: threading, funcname: _is_owned
 --- modulename: connection, funcname: send_bytes
threading.py(258):         if self._lock.acquire(0):
connection.py(183):         self._check_closed()
threading.py(262):             return True
 --- modulename: connection, funcname: _check_closed
threading.py(347):         all_waiters = self._waiters
connection.py(135):         if self._handle is None:
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
connection.py(184):         self._check_writable()
threading.py(349):         if not waiters_to_notify:
 --- modulename: connection, funcname: _check_writable
threading.py(350):             return
connection.py(143):         if not self._writable:
 --- modulename: threading, funcname: __exit__
connection.py(185):         m = memoryview(buf)
threading.py(244):         return self._lock.__exit__(*args)
connection.py(187):         if m.itemsize > 1:
process.py(334):                     n_sentinels_sent += 1
connection.py(189):         n = len(m)
process.py(331):             for i in range(n_children_to_stop - n_sentinels_sent):
connection.py(190):         if offset < 0:
process.py(332):                 try:
connection.py(192):         if n < offset:
process.py(333):                     call_queue.put_nowait(None)
connection.py(194):         if size is None:
 --- modulename: queues, funcname: put_nowait
connection.py(195):             size = n - offset
queues.py(129):         return self.put(obj, False)
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: queues, funcname: put
 --- modulename: connection, funcname: _send_bytes
queues.py(81):         assert not self._closed, "Queue {0!r} has been closed".format(self)
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
queues.py(82):         if not self._sem.acquire(block, timeout):
connection.py(281):             try:
queues.py(85):         with self._notempty:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
 --- modulename: threading, funcname: __enter__
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
threading.py(241):         return self._lock.__enter__()
connection.py(291):             assert err == 0
queues.py(86):             if self._thread is None:
connection.py(292):             assert nwritten == len(buf)
queues.py(88):             self._buffer.append(obj)
queues.py(229):                         obj = bpopleft()
queues.py(89):             self._notempty.notify()
queues.py(230):                         if obj is sentinel:
 --- modulename: threading, funcname: notify
queues.py(236):                         obj = _ForkingPickler.dumps(obj)
threading.py(345):         if not self._is_owned():
 --- modulename: reduction, funcname: dumps
 --- modulename: threading, funcname: _is_owned
reduction.py(50):         buf = io.BytesIO()
threading.py(258):         if self._lock.acquire(0):
reduction.py(51):         cls(buf, protocol).dump(obj)
threading.py(262):             return True
 --- modulename: reduction, funcname: __init__
threading.py(347):         all_waiters = self._waiters
reduction.py(39):         super().__init__(*args)
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
threading.py(349):         if not waiters_to_notify:
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
threading.py(350):             return
reduction.py(52):         return buf.getbuffer()
 --- modulename: threading, funcname: __exit__
queues.py(237):                         if wacquire is None:
threading.py(244):         return self._lock.__exit__(*args)
queues.py(238):                             send_bytes(obj)
process.py(334):                     n_sentinels_sent += 1
 --- modulename: connection, funcname: send_bytes
process.py(331):             for i in range(n_children_to_stop - n_sentinels_sent):
connection.py(183):         self._check_closed()
process.py(332):                 try:
 --- modulename: connection, funcname: _check_closed
process.py(333):                     call_queue.put_nowait(None)
connection.py(135):         if self._handle is None:
 --- modulename: queues, funcname: put_nowait
connection.py(184):         self._check_writable()
queues.py(129):         return self.put(obj, False)
 --- modulename: connection, funcname: _check_writable
 --- modulename: queues, funcname: put
connection.py(143):         if not self._writable:
queues.py(81):         assert not self._closed, "Queue {0!r} has been closed".format(self)
connection.py(185):         m = memoryview(buf)
queues.py(82):         if not self._sem.acquire(block, timeout):
connection.py(187):         if m.itemsize > 1:
queues.py(85):         with self._notempty:
connection.py(189):         n = len(m)
 --- modulename: threading, funcname: __enter__
connection.py(190):         if offset < 0:
threading.py(241):         return self._lock.__enter__()
connection.py(192):         if n < offset:
queues.py(86):             if self._thread is None:
connection.py(194):         if size is None:
queues.py(88):             self._buffer.append(obj)
connection.py(195):             size = n - offset
queues.py(89):             self._notempty.notify()
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: threading, funcname: notify
 --- modulename: connection, funcname: _send_bytes
threading.py(345):         if not self._is_owned():
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
 --- modulename: threading, funcname: _is_owned
connection.py(281):             try:
threading.py(258):         if self._lock.acquire(0):
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
threading.py(262):             return True
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
threading.py(347):         all_waiters = self._waiters
connection.py(291):             assert err == 0
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
connection.py(292):             assert nwritten == len(buf)
threading.py(349):         if not waiters_to_notify:
queues.py(229):                         obj = bpopleft()
threading.py(350):             return
queues.py(230):                         if obj is sentinel:
 --- modulename: threading, funcname: __exit__
queues.py(236):                         obj = _ForkingPickler.dumps(obj)
threading.py(244):         return self._lock.__exit__(*args)
 --- modulename: reduction, funcname: dumps
process.py(334):                     n_sentinels_sent += 1
reduction.py(50):         buf = io.BytesIO()
process.py(331):             for i in range(n_children_to_stop - n_sentinels_sent):
reduction.py(51):         cls(buf, protocol).dump(obj)
process.py(337):             n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: reduction, funcname: __init__
 --- modulename: process, funcname: <genexpr>
reduction.py(39):         super().__init__(*args)
process.py(337):             n_children_alive = sum(p.is_alive() for p in processes.values())
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
 --- modulename: process, funcname: is_alive
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
process.py(148):         self._check_closed()
reduction.py(52):         return buf.getbuffer()
 --- modulename: process, funcname: _check_closed
queues.py(237):                         if wacquire is None:
process.py(91):         if self._closed:
queues.py(238):                             send_bytes(obj)
process.py(149):         if self is _current_process:
 --- modulename: connection, funcname: send_bytes
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
connection.py(183):         self._check_closed()
process.py(153):         if self._popen is None:
 --- modulename: connection, funcname: _check_closed
process.py(156):         returncode = self._popen.poll()
connection.py(135):         if self._handle is None:
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
connection.py(184):         self._check_writable()
 --- modulename: popen_spawn_win32, funcname: wait
 --- modulename: connection, funcname: _check_writable
popen_spawn_win32.py(98):         if self.returncode is None:
connection.py(143):         if not self._writable:
popen_spawn_win32.py(99):             if timeout is None:
connection.py(185):         m = memoryview(buf)
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
connection.py(187):         if m.itemsize > 1:
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
connection.py(189):         n = len(m)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(106):                 code = _winapi.GetExitCodeProcess(self._handle)
connection.py(190):         if offset < 0:
popen_spawn_win32.py(107):                 if code == TERMINATE:
connection.py(192):         if n < offset:
popen_spawn_win32.py(109):                 self.returncode = code
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
popen_spawn_win32.py(111):         return self.returncode
connection.py(200):         self._send_bytes(m[offset:offset + size])
process.py(157):         if returncode is None:
 --- modulename: connection, funcname: _send_bytes
process.py(160):             _children.discard(self)
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
process.py(161):             return False
connection.py(281):             try:
 --- modulename: process, funcname: <genexpr>
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
process.py(337):             n_children_alive = sum(p.is_alive() for p in processes.values())
 --- modulename: process, funcname: is_alive
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
process.py(148):         self._check_closed()
connection.py(292):             assert nwritten == len(buf)
 --- modulename: process, funcname: _check_closed
queues.py(229):                         obj = bpopleft()
process.py(91):         if self._closed:
queues.py(230):                         if obj is sentinel:
process.py(149):         if self is _current_process:
queues.py(236):                         obj = _ForkingPickler.dumps(obj)
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
 --- modulename: reduction, funcname: dumps
process.py(153):         if self._popen is None:
reduction.py(50):         buf = io.BytesIO()
reduction.py(51):         cls(buf, protocol).dump(obj)
process.py(156):         returncode = self._popen.poll()
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
 --- modulename: popen_spawn_win32, funcname: poll
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
popen_spawn_win32.py(114):         return self.wait(timeout=0)
reduction.py(52):         return buf.getbuffer()
queues.py(237):                         if wacquire is None:
queues.py(238):                             send_bytes(obj)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
 --- modulename: popen_spawn_win32, funcname: wait
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
popen_spawn_win32.py(98):         if self.returncode is None:
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
popen_spawn_win32.py(99):             if timeout is None:
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
connection.py(200):         self._send_bytes(m[offset:offset + size])
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
 --- modulename: connection, funcname: _send_bytes
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
popen_spawn_win32.py(111):         return self.returncode
connection.py(281):             try:
process.py(157):         if returncode is None:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
process.py(158):             return True
 --- modulename: process, funcname: <genexpr>
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
queues.py(229):                         obj = bpopleft()
process.py(337):             n_children_alive = sum(p.is_alive() for p in processes.values())
queues.py(245):                 except IndexError:
 --- modulename: process, funcname: is_alive
queues.py(246):                     pass
process.py(148):         self._check_closed()
queues.py(220):             try:
 --- modulename: process, funcname: _check_closed
queues.py(221):                 nacquire()
process.py(91):         if self._closed:
queues.py(222):                 try:
process.py(149):         if self is _current_process:
queues.py(223):                     if not buffer:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
queues.py(224):                         nwait()
process.py(153):         if self._popen is None:
 --- modulename: threading, funcname: wait
process.py(156):         returncode = self._popen.poll()
threading.py(287):         if not self._is_owned():
 --- modulename: popen_spawn_win32, funcname: poll
 --- modulename: threading, funcname: _is_owned
popen_spawn_win32.py(114):         return self.wait(timeout=0)
threading.py(258):         if self._lock.acquire(0):
 --- modulename: popen_spawn_win32, funcname: wait
threading.py(262):             return True
popen_spawn_win32.py(98):         if self.returncode is None:
threading.py(289):         waiter = _allocate_lock()
popen_spawn_win32.py(99):             if timeout is None:
threading.py(290):         waiter.acquire()
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
threading.py(291):         self._waiters.append(waiter)
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
threading.py(292):         saved_state = self._release_save()
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
 --- modulename: threading, funcname: _release_save
popen_spawn_win32.py(111):         return self.returncode
threading.py(250):         self._lock.release()           # No state to save
process.py(157):         if returncode is None:
threading.py(293):         gotit = False
process.py(158):             return True
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
 --- modulename: process, funcname: <genexpr>
threading.py(295):             if timeout is None:
process.py(337):             n_children_alive = sum(p.is_alive() for p in processes.values())
threading.py(296):                 waiter.acquire()
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(106):                 code = _winapi.GetExitCodeProcess(self._handle)
popen_spawn_win32.py(107):                 if code == TERMINATE:
popen_spawn_win32.py(109):                 self.returncode = code
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(160):             _children.discard(self)
process.py(161):             return False
 --- modulename: process, funcname: <genexpr>
process.py(337):             n_children_alive = sum(p.is_alive() for p in processes.values())
process.py(330):         while n_sentinels_sent < n_children_to_stop and n_children_alive > 0:
process.py(340):         call_queue.close()
 --- modulename: queues, funcname: close
queues.py(132):         self._closed = True
queues.py(133):         try:
queues.py(134):             self._reader.close()
 --- modulename: connection, funcname: close
connection.py(175):         if self._handle is not None:
connection.py(176):             try:
connection.py(177):                 self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
connection.py(179):                 self._handle = None
queues.py(136):             close = self._close
queues.py(137):             if close:
queues.py(138):                 self._close = None
queues.py(139):                 close()
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
 --- modulename: queues, funcname: _finalize_close
queues.py(199):         debug('telling queue thread to quit')
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
queues.py(200):         with notempty:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
queues.py(201):             buffer.append(_sentinel)
queues.py(202):             notempty.notify()
 --- modulename: threading, funcname: notify
threading.py(345):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(347):         all_waiters = self._waiters
threading.py(348):         waiters_to_notify = _deque(_islice(all_waiters, n))
threading.py(349):         if not waiters_to_notify:
threading.py(351):         for waiter in waiters_to_notify:
threading.py(352):             waiter.release()
threading.py(353):             try:
threading.py(297):                 gotit = True
threading.py(354):                 all_waiters.remove(waiter)
threading.py(303):             return gotit
threading.py(351):         for waiter in waiters_to_notify:
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: __exit__
 --- modulename: threading, funcname: _acquire_restore
threading.py(244):         return self._lock.__exit__(*args)
threading.py(253):         self._lock.acquire()           # Ignore saved state
util.py(191):                             self._kwargs = self._key = None
threading.py(306):             if not gotit:
util.py(192):             return res
queues.py(226):                     nrelease()
process.py(343):         for p in processes.values():
queues.py(227):                 try:
process.py(344):             p.join()
queues.py(228):                     while 1:
 --- modulename: process, funcname: join
queues.py(229):                         obj = bpopleft()
process.py(137):         self._check_closed()
queues.py(230):                         if obj is sentinel:
 --- modulename: process, funcname: _check_closed
queues.py(231):                             debug('feeder thread got sentinel -- exiting')
process.py(91):         if self._closed:
 --- modulename: util, funcname: debug
process.py(138):         assert self._parent_pid == os.getpid(), 'can only join a child process'
util.py(49):     if _logger:
process.py(139):         assert self._popen is not None, 'can only join a started process'
queues.py(232):                             close()
process.py(140):         res = self._popen.wait(timeout)
 --- modulename: connection, funcname: close
 --- modulename: popen_spawn_win32, funcname: wait
connection.py(175):         if self._handle is not None:
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(111):         return self.returncode
connection.py(176):             try:
process.py(141):         if res is not None:
connection.py(177):                 self._close()
process.py(142):             _children.discard(self)
 --- modulename: connection, funcname: _close
process.py(343):         for p in processes.values():
connection.py(277):             _CloseHandle(self._handle)
process.py(344):             p.join()
connection.py(179):                 self._handle = None
 --- modulename: process, funcname: join
queues.py(233):                             return
process.py(137):         self._check_closed()
threading.py(874):             del self._target, self._args, self._kwargs
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(138):         assert self._parent_pid == os.getpid(), 'can only join a child process'
process.py(139):         assert self._popen is not None, 'can only join a started process'
process.py(140):         res = self._popen.wait(timeout)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(100):                 msecs = _winapi.INFINITE
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(106):                 code = _winapi.GetExitCodeProcess(self._handle)
popen_spawn_win32.py(107):                 if code == TERMINATE:
popen_spawn_win32.py(109):                 self.returncode = code
popen_spawn_win32.py(111):         return self.returncode
process.py(141):         if res is not None:
process.py(142):             _children.discard(self)
process.py(343):         for p in processes.values():
process.py(344):             p.join()
 --- modulename: process, funcname: join
process.py(137):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(138):         assert self._parent_pid == os.getpid(), 'can only join a child process'
process.py(139):         assert self._popen is not None, 'can only join a started process'
process.py(140):         res = self._popen.wait(timeout)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(100):                 msecs = _winapi.INFINITE
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(106):                 code = _winapi.GetExitCodeProcess(self._handle)
popen_spawn_win32.py(107):                 if code == TERMINATE:
popen_spawn_win32.py(109):                 self.returncode = code
popen_spawn_win32.py(111):         return self.returncode
process.py(141):         if res is not None:
process.py(142):             _children.discard(self)
process.py(343):         for p in processes.values():
process.py(344):             p.join()
 --- modulename: process, funcname: join
process.py(137):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(138):         assert self._parent_pid == os.getpid(), 'can only join a child process'
process.py(139):         assert self._popen is not None, 'can only join a started process'
process.py(140):         res = self._popen.wait(timeout)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(111):         return self.returncode
process.py(141):         if res is not None:
process.py(142):             _children.discard(self)
process.py(343):         for p in processes.values():
process.py(441):                     return
threading.py(874):             del self._target, self._args, self._kwargs
threading.py(1061):             lock.release()
threading.py(1062):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(994):         lock = self._tstate_lock
threading.py(995):         if lock is not None:
threading.py(996):             assert not lock.locked()
threading.py(997):         self._is_stopped = True
threading.py(998):         self._tstate_lock = None
threading.py(999):         if not self.daemon:
 --- modulename: threading, funcname: daemon
threading.py(1129):         assert self._initialized, "Thread.__init__() not called"
threading.py(1130):         return self._daemonic
process.py(684):         self._queue_management_thread = None
 --- modulename: weakref, funcname: remove
weakref.py(359):             self = selfref()
weakref.py(360):             if self is not None:
weakref.py(361):                 if self._iterating:
weakref.py(364):                     del self.data[k]
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
process.py(685):         if self._call_queue is not None:
process.py(686):             self._call_queue.close()
 --- modulename: queues, funcname: close
queues.py(132):         self._closed = True
queues.py(133):         try:
queues.py(134):             self._reader.close()
 --- modulename: connection, funcname: close
connection.py(175):         if self._handle is not None:
queues.py(136):             close = self._close
queues.py(137):             if close:
process.py(687):             if wait:
process.py(688):                 self._call_queue.join_thread()
 --- modulename: queues, funcname: join_thread
queues.py(142):         debug('Queue.join_thread()')
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
queues.py(143):         assert self._closed, "Queue {0!r} not closed".format(self)
queues.py(144):         if self._jointhread:
queues.py(145):             self._jointhread()
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
 --- modulename: queues, funcname: _finalize_join
queues.py(189):         debug('joining queue thread')
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
queues.py(190):         thread = twr()
queues.py(191):         if thread is not None:
queues.py(192):             thread.join()
 --- modulename: threading, funcname: join
threading.py(1036):         if not self._initialized:
threading.py(1038):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1040):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
threading.py(1043):         if timeout is None:
threading.py(1044):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1057):         lock = self._tstate_lock
threading.py(1058):         if lock is None:  # already determined that the C code is done
threading.py(1060):         elif lock.acquire(block, timeout):
threading.py(1061):             lock.release()
threading.py(1062):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(994):         lock = self._tstate_lock
threading.py(995):         if lock is not None:
threading.py(996):             assert not lock.locked()
threading.py(997):         self._is_stopped = True
threading.py(998):         self._tstate_lock = None
threading.py(999):         if not self.daemon:
 --- modulename: threading, funcname: daemon
threading.py(1129):         assert self._initialized, "Thread.__init__() not called"
threading.py(1130):         return self._daemonic
queues.py(193):             debug('... queue thread joined')
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
process.py(689):             self._call_queue = None
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
process.py(690):         self._result_queue = None
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
connection.py(132):             self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
connection.py(132):             self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
process.py(691):         self._processes = None
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
process.py(693):         if self._queue_management_thread_wakeup:
process.py(694):             self._queue_management_thread_wakeup.close()
 --- modulename: process, funcname: close
process.py(86):         self._writer.close()
 --- modulename: connection, funcname: close
connection.py(175):         if self._handle is not None:
connection.py(176):             try:
connection.py(177):                 self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
connection.py(179):                 self._handle = None
process.py(87):         self._reader.close()
 --- modulename: connection, funcname: close
connection.py(175):         if self._handle is not None:
connection.py(176):             try:
connection.py(177):                 self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
connection.py(179):                 self._handle = None
process.py(695):             self._queue_management_thread_wakeup = None
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
_base.py(624):         return False
 --- modulename: weakref, funcname: remove
weakref.py(110):             self = selfref()
weakref.py(111):             if self is not None:
weakref.py(112):                 if self._iterating:
weakref.py(117):                     _atomic_removal(d, wr.key)
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
 --- modulename: managers, funcname: _decref
managers.py(864):         idset.discard(token.id)
managers.py(867):         if state is None or state.value == State.STARTED:
managers.py(869):             try:
managers.py(870):                 util.debug('DECREF %r', token.id)
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
managers.py(871):                 conn = _Client(token.address, authkey=authkey)
 --- modulename: connection, funcname: Client
connection.py(487):     family = family or address_type(address)
 --- modulename: connection, funcname: address_type
connection.py(101):     if type(address) == tuple:
connection.py(103):     elif type(address) is str and address.startswith('\\\\'):
connection.py(104):         return 'AF_PIPE'
connection.py(488):     _validate_family(family)
 --- modulename: connection, funcname: _validate_family
connection.py(87):     if sys.platform != 'win32' and family == 'AF_PIPE':
connection.py(90):     if sys.platform == 'win32' and family == 'AF_UNIX':
connection.py(489):     if family == 'AF_PIPE':
connection.py(490):         c = PipeClient(address)
 --- modulename: connection, funcname: PipeClient
connection.py(688):         t = _init_timeout()
 --- modulename: connection, funcname: _init_timeout
connection.py(60):     return time.monotonic() + timeout
connection.py(689):         while 1:
connection.py(690):             try:
connection.py(691):                 _winapi.WaitNamedPipe(address, 1000)
connection.py(692):                 h = _winapi.CreateFile(
connection.py(693):                     address, _winapi.GENERIC_READ | _winapi.GENERIC_WRITE,
connection.py(694):                     0, _winapi.NULL, _winapi.OPEN_EXISTING,
connection.py(695):                     _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL
connection.py(702):                 break
connection.py(706):         _winapi.SetNamedPipeHandleState(
connection.py(707):             h, _winapi.PIPE_READMODE_MESSAGE, None, None
connection.py(709):         return PipeConnection(h)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(494):     if authkey is not None and not isinstance(authkey, bytes):
connection.py(497):     if authkey is not None:
connection.py(498):         answer_challenge(c, authkey)
 --- modulename: connection, funcname: answer_challenge
connection.py(737):     import hmac
connection.py(738):     if not isinstance(authkey, bytes):
connection.py(741):     message = connection.recv_bytes(256)         # reject large message
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
connection.py(742):     assert message[:len(CHALLENGE)] == CHALLENGE, 'message = %r' % message
connection.py(743):     message = message[len(CHALLENGE):]
connection.py(744):     digest = hmac.new(authkey, message, 'md5').digest()
 --- modulename: hmac, funcname: new
hmac.py(153):     return HMAC(key, msg, digestmod)
 --- modulename: hmac, funcname: __init__
hmac.py(48):         if not isinstance(key, (bytes, bytearray)):
hmac.py(51):         if digestmod is None:
hmac.py(58):         if callable(digestmod):
hmac.py(60):         elif isinstance(digestmod, str):
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
hmac.py(65):         self.outer = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(66):         self.inner = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(67):         self.digest_size = self.inner.digest_size
hmac.py(69):         if hasattr(self.inner, 'block_size'):
hmac.py(70):             blocksize = self.inner.block_size
hmac.py(71):             if blocksize < 16:
hmac.py(84):         self.block_size = blocksize
hmac.py(86):         if len(key) > blocksize:
hmac.py(89):         key = key.ljust(blocksize, b'\0')
hmac.py(90):         self.outer.update(key.translate(trans_5C))
hmac.py(91):         self.inner.update(key.translate(trans_36))
hmac.py(92):         if msg is not None:
hmac.py(93):             self.update(msg)
 --- modulename: hmac, funcname: update
hmac.py(102):         self.inner.update(msg)
 --- modulename: hmac, funcname: digest
hmac.py(133):         h = self._current()
 --- modulename: hmac, funcname: _current
hmac.py(122):         h = self.outer.copy()
hmac.py(123):         h.update(self.inner.digest())
hmac.py(124):         return h
hmac.py(134):         return h.digest()
connection.py(745):     connection.send_bytes(digest)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
connection.py(746):     response = connection.recv_bytes(256)        # reject large message
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
connection.py(747):     if response != WELCOME:
connection.py(499):         deliver_challenge(c, authkey)
 --- modulename: connection, funcname: deliver_challenge
connection.py(722):     import hmac
connection.py(723):     if not isinstance(authkey, bytes):
connection.py(726):     message = os.urandom(MESSAGE_LENGTH)
connection.py(727):     connection.send_bytes(CHALLENGE + message)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
connection.py(728):     digest = hmac.new(authkey, message, 'md5').digest()
 --- modulename: hmac, funcname: new
hmac.py(153):     return HMAC(key, msg, digestmod)
 --- modulename: hmac, funcname: __init__
hmac.py(48):         if not isinstance(key, (bytes, bytearray)):
hmac.py(51):         if digestmod is None:
hmac.py(58):         if callable(digestmod):
hmac.py(60):         elif isinstance(digestmod, str):
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
hmac.py(65):         self.outer = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(66):         self.inner = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(67):         self.digest_size = self.inner.digest_size
hmac.py(69):         if hasattr(self.inner, 'block_size'):
hmac.py(70):             blocksize = self.inner.block_size
hmac.py(71):             if blocksize < 16:
hmac.py(84):         self.block_size = blocksize
hmac.py(86):         if len(key) > blocksize:
hmac.py(89):         key = key.ljust(blocksize, b'\0')
hmac.py(90):         self.outer.update(key.translate(trans_5C))
hmac.py(91):         self.inner.update(key.translate(trans_36))
hmac.py(92):         if msg is not None:
hmac.py(93):             self.update(msg)
 --- modulename: hmac, funcname: update
hmac.py(102):         self.inner.update(msg)
 --- modulename: hmac, funcname: digest
hmac.py(133):         h = self._current()
 --- modulename: hmac, funcname: _current
hmac.py(122):         h = self.outer.copy()
hmac.py(123):         h.update(self.inner.digest())
hmac.py(124):         return h
hmac.py(134):         return h.digest()
connection.py(729):     response = connection.recv_bytes(256)        # reject large message
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
connection.py(730):     if response == digest:
connection.py(731):         connection.send_bytes(WELCOME)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
connection.py(501):     return c
managers.py(872):                 dispatch(conn, None, 'decref', (token.id,))
 --- modulename: managers, funcname: dispatch
managers.py(78):     c.send((id, methodname, args, kwds))
 --- modulename: connection, funcname: send
connection.py(204):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(205):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(206):         self._send_bytes(_ForkingPickler.dumps(obj))
 --- modulename: reduction, funcname: dumps
reduction.py(50):         buf = io.BytesIO()
reduction.py(51):         cls(buf, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
reduction.py(52):         return buf.getbuffer()
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
managers.py(79):     kind, result = c.recv()
 --- modulename: connection, funcname: recv
connection.py(248):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(249):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(250):         buf = self._recv_bytes()
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(251):         return _ForkingPickler.loads(buf.getbuffer())
managers.py(80):     if kind == '#RETURN':
managers.py(81):         return result
managers.py(881):         if not idset and hasattr(tls, 'connection'):
managers.py(882):             util.debug('thread %r has no more proxies so closing conn',
managers.py(883):                        threading.current_thread().name)
 --- modulename: threading, funcname: current_thread
threading.py(1233):     try:
threading.py(1234):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1072):         assert self._initialized, "Thread.__init__() not called"
threading.py(1073):         return self._name
 --- modulename: util, funcname: debug
util.py(49):     if _logger:
managers.py(884):             tls.connection.close()
 --- modulename: connection, funcname: close
connection.py(175):         if self._handle is not None:
connection.py(176):             try:
connection.py(177):                 self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
connection.py(179):                 self._handle = None
managers.py(885):             del tls.connection
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
connection.py(132):             self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
 --- modulename: managers, funcname: _finalize_manager
managers.py(664):         if process.is_alive():
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(158):             return True
managers.py(665):             util.info('sending shutdown message to manager')
 --- modulename: util, funcname: info
util.py(53):     if _logger:
managers.py(666):             try:
managers.py(667):                 conn = _Client(address, authkey=authkey)
 --- modulename: connection, funcname: Client
connection.py(487):     family = family or address_type(address)
 --- modulename: connection, funcname: address_type
connection.py(101):     if type(address) == tuple:
connection.py(103):     elif type(address) is str and address.startswith('\\\\'):
connection.py(104):         return 'AF_PIPE'
connection.py(488):     _validate_family(family)
 --- modulename: connection, funcname: _validate_family
connection.py(87):     if sys.platform != 'win32' and family == 'AF_PIPE':
connection.py(90):     if sys.platform == 'win32' and family == 'AF_UNIX':
connection.py(489):     if family == 'AF_PIPE':
connection.py(490):         c = PipeClient(address)
 --- modulename: connection, funcname: PipeClient
connection.py(688):         t = _init_timeout()
 --- modulename: connection, funcname: _init_timeout
connection.py(60):     return time.monotonic() + timeout
connection.py(689):         while 1:
connection.py(690):             try:
connection.py(691):                 _winapi.WaitNamedPipe(address, 1000)
connection.py(692):                 h = _winapi.CreateFile(
connection.py(693):                     address, _winapi.GENERIC_READ | _winapi.GENERIC_WRITE,
connection.py(694):                     0, _winapi.NULL, _winapi.OPEN_EXISTING,
connection.py(695):                     _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL
connection.py(702):                 break
connection.py(706):         _winapi.SetNamedPipeHandleState(
connection.py(707):             h, _winapi.PIPE_READMODE_MESSAGE, None, None
connection.py(709):         return PipeConnection(h)
 --- modulename: connection, funcname: __init__
connection.py(118):         handle = handle.__index__()
connection.py(119):         if handle < 0:
connection.py(121):         if not readable and not writable:
connection.py(124):         self._handle = handle
connection.py(125):         self._readable = readable
connection.py(126):         self._writable = writable
connection.py(494):     if authkey is not None and not isinstance(authkey, bytes):
connection.py(497):     if authkey is not None:
connection.py(498):         answer_challenge(c, authkey)
 --- modulename: connection, funcname: answer_challenge
connection.py(737):     import hmac
connection.py(738):     if not isinstance(authkey, bytes):
connection.py(741):     message = connection.recv_bytes(256)         # reject large message
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
connection.py(742):     assert message[:len(CHALLENGE)] == CHALLENGE, 'message = %r' % message
connection.py(743):     message = message[len(CHALLENGE):]
connection.py(744):     digest = hmac.new(authkey, message, 'md5').digest()
 --- modulename: hmac, funcname: new
hmac.py(153):     return HMAC(key, msg, digestmod)
 --- modulename: hmac, funcname: __init__
hmac.py(48):         if not isinstance(key, (bytes, bytearray)):
hmac.py(51):         if digestmod is None:
hmac.py(58):         if callable(digestmod):
hmac.py(60):         elif isinstance(digestmod, str):
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
hmac.py(65):         self.outer = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(66):         self.inner = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(67):         self.digest_size = self.inner.digest_size
hmac.py(69):         if hasattr(self.inner, 'block_size'):
hmac.py(70):             blocksize = self.inner.block_size
hmac.py(71):             if blocksize < 16:
hmac.py(84):         self.block_size = blocksize
hmac.py(86):         if len(key) > blocksize:
hmac.py(89):         key = key.ljust(blocksize, b'\0')
hmac.py(90):         self.outer.update(key.translate(trans_5C))
hmac.py(91):         self.inner.update(key.translate(trans_36))
hmac.py(92):         if msg is not None:
hmac.py(93):             self.update(msg)
 --- modulename: hmac, funcname: update
hmac.py(102):         self.inner.update(msg)
 --- modulename: hmac, funcname: digest
hmac.py(133):         h = self._current()
 --- modulename: hmac, funcname: _current
hmac.py(122):         h = self.outer.copy()
hmac.py(123):         h.update(self.inner.digest())
hmac.py(124):         return h
hmac.py(134):         return h.digest()
connection.py(745):     connection.send_bytes(digest)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
connection.py(746):     response = connection.recv_bytes(256)        # reject large message
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
connection.py(747):     if response != WELCOME:
connection.py(499):         deliver_challenge(c, authkey)
 --- modulename: connection, funcname: deliver_challenge
connection.py(722):     import hmac
connection.py(723):     if not isinstance(authkey, bytes):
connection.py(726):     message = os.urandom(MESSAGE_LENGTH)
connection.py(727):     connection.send_bytes(CHALLENGE + message)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
connection.py(728):     digest = hmac.new(authkey, message, 'md5').digest()
 --- modulename: hmac, funcname: new
hmac.py(153):     return HMAC(key, msg, digestmod)
 --- modulename: hmac, funcname: __init__
hmac.py(48):         if not isinstance(key, (bytes, bytearray)):
hmac.py(51):         if digestmod is None:
hmac.py(58):         if callable(digestmod):
hmac.py(60):         elif isinstance(digestmod, str):
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
hmac.py(65):         self.outer = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(66):         self.inner = self.digest_cons()
 --- modulename: hmac, funcname: <lambda>
hmac.py(61):             self.digest_cons = lambda d=b'': _hashlib.new(digestmod, d)
 --- modulename: hashlib, funcname: __hash_new
hashlib.py(143):     if name in {'blake2b', 'blake2s'}:
hashlib.py(149):     try:
hashlib.py(150):         return _hashlib.new(name, data)
hmac.py(67):         self.digest_size = self.inner.digest_size
hmac.py(69):         if hasattr(self.inner, 'block_size'):
hmac.py(70):             blocksize = self.inner.block_size
hmac.py(71):             if blocksize < 16:
hmac.py(84):         self.block_size = blocksize
hmac.py(86):         if len(key) > blocksize:
hmac.py(89):         key = key.ljust(blocksize, b'\0')
hmac.py(90):         self.outer.update(key.translate(trans_5C))
hmac.py(91):         self.inner.update(key.translate(trans_36))
hmac.py(92):         if msg is not None:
hmac.py(93):             self.update(msg)
 --- modulename: hmac, funcname: update
hmac.py(102):         self.inner.update(msg)
 --- modulename: hmac, funcname: digest
hmac.py(133):         h = self._current()
 --- modulename: hmac, funcname: _current
hmac.py(122):         h = self.outer.copy()
hmac.py(123):         h.update(self.inner.digest())
hmac.py(124):         return h
hmac.py(134):         return h.digest()
connection.py(729):     response = connection.recv_bytes(256)        # reject large message
 --- modulename: connection, funcname: recv_bytes
connection.py(212):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(213):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(214):         if maxlength is not None and maxlength < 0:
connection.py(216):         buf = self._recv_bytes(maxlength)
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(217):         if buf is None:
connection.py(219):         return buf.getvalue()
connection.py(730):     if response == digest:
connection.py(731):         connection.send_bytes(WELCOME)
 --- modulename: connection, funcname: send_bytes
connection.py(183):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(184):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(185):         m = memoryview(buf)
connection.py(187):         if m.itemsize > 1:
connection.py(189):         n = len(m)
connection.py(190):         if offset < 0:
connection.py(192):         if n < offset:
connection.py(194):         if size is None:
connection.py(195):             size = n - offset
connection.py(200):         self._send_bytes(m[offset:offset + size])
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
connection.py(501):     return c
managers.py(668):                 try:
managers.py(669):                     dispatch(conn, None, 'shutdown')
 --- modulename: managers, funcname: dispatch
managers.py(78):     c.send((id, methodname, args, kwds))
 --- modulename: connection, funcname: send
connection.py(204):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(205):         self._check_writable()
 --- modulename: connection, funcname: _check_writable
connection.py(143):         if not self._writable:
connection.py(206):         self._send_bytes(_ForkingPickler.dumps(obj))
 --- modulename: reduction, funcname: dumps
reduction.py(50):         buf = io.BytesIO()
reduction.py(51):         cls(buf, protocol).dump(obj)
 --- modulename: reduction, funcname: __init__
reduction.py(39):         super().__init__(*args)
reduction.py(40):         self.dispatch_table = self._copyreg_dispatch_table.copy()
reduction.py(41):         self.dispatch_table.update(self._extra_reducers)
reduction.py(52):         return buf.getbuffer()
 --- modulename: connection, funcname: _send_bytes
connection.py(280):             ov, err = _winapi.WriteFile(self._handle, buf, overlapped=True)
connection.py(281):             try:
connection.py(282):                 if err == _winapi.ERROR_IO_PENDING:
connection.py(290):                 nwritten, err = ov.GetOverlappedResult(True)
connection.py(291):             assert err == 0
connection.py(292):             assert nwritten == len(buf)
managers.py(79):     kind, result = c.recv()
 --- modulename: connection, funcname: recv
connection.py(248):         self._check_closed()
 --- modulename: connection, funcname: _check_closed
connection.py(135):         if self._handle is None:
connection.py(249):         self._check_readable()
 --- modulename: connection, funcname: _check_readable
connection.py(139):         if not self._readable:
connection.py(250):         buf = self._recv_bytes()
 --- modulename: connection, funcname: _recv_bytes
connection.py(295):             if self._got_empty_message:
connection.py(299):                 bsize = 128 if maxsize is None else min(maxsize, 128)
connection.py(300):                 try:
connection.py(301):                     ov, err = _winapi.ReadFile(self._handle, bsize,
connection.py(302):                                                 overlapped=True)
connection.py(303):                     try:
connection.py(304):                         if err == _winapi.ERROR_IO_PENDING:
connection.py(312):                         nread, err = ov.GetOverlappedResult(True)
connection.py(313):                         if err == 0:
connection.py(314):                             f = io.BytesIO()
connection.py(315):                             f.write(ov.getbuffer())
connection.py(316):                             return f
connection.py(251):         return _ForkingPickler.loads(buf.getbuffer())
managers.py(80):     if kind == '#RETURN':
managers.py(81):         return result
managers.py(671):                     conn.close()
 --- modulename: connection, funcname: close
connection.py(175):         if self._handle is not None:
connection.py(176):             try:
connection.py(177):                 self._close()
 --- modulename: connection, funcname: _close
connection.py(277):             _CloseHandle(self._handle)
connection.py(179):                 self._handle = None
managers.py(675):             process.join(timeout=1.0)
 --- modulename: process, funcname: join
process.py(137):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(138):         assert self._parent_pid == os.getpid(), 'can only join a child process'
process.py(139):         assert self._popen is not None, 'can only join a started process'
process.py(140):         res = self._popen.wait(timeout)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(99):             if timeout is None:
popen_spawn_win32.py(102):                 msecs = max(0, int(timeout * 1000 + 0.5))
popen_spawn_win32.py(104):             res = _winapi.WaitForSingleObject(int(self._handle), msecs)
popen_spawn_win32.py(105):             if res == _winapi.WAIT_OBJECT_0:
popen_spawn_win32.py(106):                 code = _winapi.GetExitCodeProcess(self._handle)
popen_spawn_win32.py(107):                 if code == TERMINATE:
popen_spawn_win32.py(109):                 self.returncode = code
popen_spawn_win32.py(111):         return self.returncode
process.py(141):         if res is not None:
process.py(142):             _children.discard(self)
managers.py(676):             if process.is_alive():
 --- modulename: process, funcname: is_alive
process.py(148):         self._check_closed()
 --- modulename: process, funcname: _check_closed
process.py(91):         if self._closed:
process.py(149):         if self is _current_process:
process.py(151):         assert self._parent_pid == os.getpid(), 'can only test a child process'
process.py(153):         if self._popen is None:
process.py(156):         returncode = self._popen.poll()
 --- modulename: popen_spawn_win32, funcname: poll
popen_spawn_win32.py(114):         return self.wait(timeout=0)
 --- modulename: popen_spawn_win32, funcname: wait
popen_spawn_win32.py(98):         if self.returncode is None:
popen_spawn_win32.py(111):         return self.returncode
process.py(157):         if returncode is None:
process.py(160):             _children.discard(self)
process.py(161):             return False
managers.py(685):         state.value = State.SHUTDOWN
managers.py(686):         try:
managers.py(687):             del BaseProxy._address_to_local[address]
 --- modulename: weakref, funcname: remove
weakref.py(110):             self = selfref()
weakref.py(111):             if self is not None:
weakref.py(112):                 if self._iterating:
weakref.py(117):                     _atomic_removal(d, wr.key)
 --- modulename: weakref, funcname: remove
weakref.py(110):             self = selfref()
weakref.py(111):             if self is not None:
weakref.py(112):                 if self._iterating:
weakref.py(117):                     _atomic_removal(d, wr.key)
 --- modulename: connection, funcname: __del__
connection.py(131):         if self._handle is not None:
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
 --- modulename: _weakrefset, funcname: _remove
_weakrefset.py(39):             self = selfref()
_weakrefset.py(40):             if self is not None:
_weakrefset.py(41):                 if self._iterating:
_weakrefset.py(44):                     self.data.discard(item)
 --- modulename: util, funcname: __call__
util.py(178):         try:
util.py(179):             del _finalizer_registry[self._key]
util.py(183):             if self._pid != getpid():
util.py(187):                 sub_debug('finalizer calling %s with args %s and kwargs %s',
util.py(188):                           self._callback, self._args, self._kwargs)
 --- modulename: util, funcname: sub_debug
util.py(45):     if _logger:
util.py(189):                 res = self._callback(*self._args, **self._kwargs)
util.py(191):                             self._kwargs = self._key = None
util.py(192):             return res
 --- modulename: subprocess, funcname: __del__
subprocess.py(851):         if not self._child_created:
subprocess.py(854):         if self.returncode is None:
subprocess.py(857):             _warn("subprocess %s is still running" % self.pid,
subprocess.py(858):                   ResourceWarning, source=self)
subprocess.py(860):         self._internal_poll(_deadstate=_maxsize)
 --- modulename: subprocess, funcname: _internal_poll
subprocess.py(1215):             if self.returncode is None:
subprocess.py(1216):                 if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:
subprocess.py(1217):                     self.returncode = _GetExitCodeProcess(self._handle)
subprocess.py(1218):             return self.returncode
subprocess.py(861):         if self.returncode is None and _active is not None:
 --- modulename: subprocess, funcname: Close
subprocess.py(203):             if not self.closed:
subprocess.py(204):                 self.closed = True
subprocess.py(205):                 CloseHandle(self)
 --- modulename: process, funcname: _chain_from_iterable_of_lists
 --- modulename: _base, funcname: result_iterator

